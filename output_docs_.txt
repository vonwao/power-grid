PROCESSING: docs/ (Generated: 5/8/2025, 12:29)

====== docs/graphql-integration-benefits.md ======
Last Modified: 5/8/2025, 09:11 | Size: 12.1 KB | Lines: 420

# Benefits of Moving GraphQL Fetching into the EnhancedDataGrid Component

## Introduction

This document explains the architectural decision to move GraphQL data fetching from parent components into the `EnhancedDataGrid` library component. This change represents a significant improvement in our component architecture, providing better separation of concerns, improved state management, and enhanced reusability.

## Key Benefits

### 1. Separation of Concerns

**Before**: Parent components were responsible for both UI presentation AND data fetching logic, creating tight coupling.

```typescript
// BEFORE: In the parent component (MTMHistoryPage)
const { rows, loading, error, pageInfo, setPage, refetch } = useGraphQLData<MTMAdjustmentRow>({
  pageSize: paginationModel.pageSize,
  initialPage: paginationModel.page,
  query: GET_MTM_HISTORY,
  variables: {
    filter: combinedFilter,
  },
});

// Later in the component...
return (
  <EnhancedDataGridGraphQL
    columns={columns}
    rows={rows}
    loading={loading}
    // Many other props...
  />
);
```

**After**: Each component has a clear, focused responsibility.

```typescript
// AFTER: In the parent component (MTMHistoryPage)
return (
  <EnhancedDataGrid
    columns={columns}
    rows={[]} // Empty array - data fetching happens inside the component
    useGraphQL={true}
    query={GET_MTM_HISTORY}
    variables={{
      limit: paginationModel.pageSize,
      filter: combinedFilter,
    }}
    onGridFunctionsInit={handleGridFunctionsInit}
    // Other configuration props...
  />
);
```

```typescript
// AFTER: Inside the EnhancedDataGrid component
const {
  rows: displayRows,
  loading,
  error,
  // Other state...
} = useEnhancedDataGrid({
  columns,
  rows,
  useGraphQL,
  query,
  variables,
  // Other options...
});
```

This separation allows:
- The parent component to focus on business logic specific to the page
- The library component to handle all data fetching and grid-related concerns
- Clearer boundaries between component responsibilities
- Easier maintenance as each component has a single responsibility

### 2. Better State Management

**Before**: State management was fragmented across components, making synchronization difficult.

```typescript
// BEFORE: State management spread across parent component
const [rows, setRows] = useState<MTMAdjustmentRow[]>([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const [pageInfo, setPageInfo] = useState({
  hasNextPage: false,
  hasPreviousPage: false,
  startCursor: null,
  endCursor: null,
});
const [selectionModel, setSelectionModel] = useState<GridRowId[]>([]);
const [sortModel, setSortModel] = useState<GridSortModel>([]);
const [filterModel, setFilterModel] = useState<GridFilterModel>({
  items: [],
});
const [paginationModel, setPaginationModel] = useState<GridPaginationModel>({
  pageSize: 25,
  page: 0,
});

// Multiple handlers to keep state in sync
const handleFilterModelChange = useCallback(/* ... */);
const handleSortModelChange = useCallback(/* ... */);
const handlePaginationModelChange = useCallback(/* ... */);
const handleSelectionChange = useCallback(/* ... */);
```

**After**: State is managed cohesively in one place.

```typescript
// AFTER: In useEnhancedDataGrid hook
export function useEnhancedDataGrid<T extends { id: GridRowId }>({
  // Options...
}) {
  // Centralized state management
  const [filtersApplied, setFiltersApplied] = useState(false);
  const [internalFilterModel, setInternalFilterModel] = useState<GridFilterModel>(/* ... */);
  const [internalSortModel, setInternalSortModel] = useState<GridSortModel>(/* ... */);
  
  // Hooks composition
  const selectionState = useSelectionModel({/* ... */});
  const paginationState = usePagination({/* ... */});
  
  // GraphQL integration
  const graphQLResult = useMemo(() => {
    // Conditional fetching logic
    if (!shouldFetchData) {
      // Return empty state
    }
    
    // Fetch data with proper parameters
    return useGraphQLData<T>({/* ... */});
  }, [/* dependencies */]);
  
  // Unified handlers
  const handleFilterModelChange = useCallback((newModel: GridFilterModel) => {
    // Update internal state
    setInternalFilterModel(newModel);
    
    // Track if filters have been applied
    setFiltersApplied(newModel.items && newModel.items.length > 0);
    
    // Update GraphQL filters if needed
    if (useGraphQLFetchingRef.current && shouldFetchData) {
      graphQLResult.setFilterModel?.(/* ... */);
    }
    
    // Call external handler if provided
    if (externalOnFilterModelChange) {
      externalOnFilterModelChange(newModel);
    }
  }, [/* dependencies */]);
  
  // Similar handlers for sort and pagination
  
  // Return everything the component needs
  return {
    // Grid configuration
    columns: processedColumns,
    rows: displayRows,
    totalRows,
    loading,
    error,
    // State tracking
    filtersApplied,
    // Event handlers
    handleFilterModelChange,
    handleSortModelChange,
    handlePaginationModelChange,
    // Hooks state
    selectionState,
    paginationState,
    // GraphQL utilities
    refetch,
    resetCursors,
    pageInfo,
    // Component flags
    isEmpty,
    isLoadingWithoutFilters
  };
}
```

Benefits of centralized state management:
- Single source of truth for all grid-related state
- Proper synchronization between different aspects of state
- Consistent behavior across all grid instances
- Easier debugging when issues arise
- Support for advanced features like conditional loading

### 3. Enhanced Reusability

**Before**: The grid component was tightly coupled to the specific data fetching implementation of each parent.

```typescript
// BEFORE: Parent component needed to implement specific data fetching
const { rows, loading, error } = useCustomDataFetching(/* ... */);

// Different parent components might implement fetching differently
const { data, isLoading, isError } = useAnotherFetchingMethod(/* ... */);

// This required adapting the props for each implementation
<EnhancedDataGridGraphQL
  rows={rows || data}
  loading={loading || isLoading}
  error={error || isError}
  // Other props...
/>
```

**After**: The component is truly reusable across different contexts.

```typescript
// AFTER: Consistent usage pattern across all implementations
<EnhancedDataGrid
  columns={columns}
  useGraphQL={true}
  query={MY_GRAPHQL_QUERY}
  variables={myVariables}
  onlyLoadWithFilters={true} // Optional feature
  // Other configuration...
/>

// Or with REST API
<EnhancedDataGrid
  columns={columns}
  useGraphQL={false}
  rows={myLocalData}
  // Other configuration...
/>
```

The component now:
- Works with any GraphQL query that follows the expected structure
- Can be dropped into any page with minimal configuration
- Supports different loading strategies (eager, conditional, etc.)
- Provides a consistent API regardless of data source

### 4. Improved Developer Experience

**Before**: Developers needed to understand both the grid component AND data fetching patterns.

```typescript
// BEFORE: Developers needed to implement all this boilerplate
const handleFilterModelChange = useCallback(
  debounce((newFilterModel: GridFilterModel) => {
    setFilterModel(newFilterModel);
    filterModelRef.current = newFilterModel;
    
    // Reset to page 0 when filter changes
    setPaginationModel(prev => ({
      ...prev,
      page: 0
    }));
    
    // Need to understand how to map grid filters to GraphQL
    const graphqlFilters = mapGridFilterModelToGraphQLFilter(
      newFilterModel,
      sortModel,
      columns
    );
    
    // Need to understand the refetching mechanism
    refetch({
      variables: {
        filter: {
          ...graphqlFilters,
          ...filterValuesToGraphQLFilter(filterValues),
        }
      }
    });
  }),
  [sortModel, columns, filterValues, refetch]
);
```

**After**: Developers can focus on business logic rather than data fetching mechanics.

```typescript
// AFTER: Simple configuration with callbacks
<EnhancedDataGrid
  columns={columns}
  useGraphQL={true}
  query={GET_MTM_HISTORY}
  variables={{
    limit: paginationModel.pageSize,
    filter: combinedFilter,
  }}
  onlyLoadWithFilters={true}
  onGridFunctionsInit={handleGridFunctionsInit}
  onFilterModelChange={handleFilterModelChange}
  // Other props...
/>

// Simple callback to store grid functions
const handleGridFunctionsInit = useCallback((
  refetch,
  resetCursors,
  pageInfo
) => {
  refetchRef.current = refetch;
  setPageInfo(pageInfo);
}, []);

// Simple filter model change handler
const handleFilterModelChange = useCallback(
  debounce((newFilterModel: GridFilterModel) => {
    setFilterModel(newFilterModel);
    filterModelRef.current = newFilterModel;
  }),
  []
);
```

Benefits for developers:
- Focus on business logic rather than data fetching mechanics
- Implement new grids with significantly less code
- Leverage advanced features without understanding their implementation details
- Consistent patterns across the application

### 5. Technical Benefits

#### Conditional Loading

The library component can implement advanced features like conditional loading:

```typescript
// Inside useEnhancedDataGrid
const shouldFetchData = useMemo(() => {
  if (!useGraphQLFetchingRef.current) return false;
  if (!onlyLoadWithFiltersRef.current) return true;
  return filtersAppliedRef.current;
}, [/* No dependencies to reduce re-renders */]);

// Determine displayed rows based on configuration
const displayRows = useMemo(() => {
  if (useGraphQLFetchingRef.current) {
    if (onlyLoadWithFiltersRef.current && !filtersAppliedRef.current) {
      // Only log in development mode
      if (process.env.NODE_ENV !== 'production') {
        console.log('[useEnhancedDataGrid] Returning empty rows - filters not applied');
      }
      return [];
    }
    return graphQLRowsRef.current || [];
  }
  return rowsRef.current || [];
}, [/* No dependencies to reduce re-renders */]);
```

#### Optimized Rendering

The library component can optimize when and how data is fetched and rendered:

```typescript
// Stable references to prevent unnecessary re-renders
const useGraphQLFetchingRef = useRef(useGraphQLFetching);
useEffect(() => {
  useGraphQLFetchingRef.current = useGraphQLFetching;
}, [useGraphQLFetching]);

// JSON.stringify for deep comparison of objects
const graphQLResult = useMemo(() => {
  // Implementation...
}, [
  shouldFetchData, 
  // Use JSON.stringify for deep comparison of objects
  JSON.stringify(variables),
  JSON.stringify(internalFilterModel.items),
  JSON.stringify(internalSortModel)
]);
```

#### Consistent Error Handling

```typescript
// Inside useEnhancedDataGrid
try {
  return useGraphQLData<T>({
    pageSize: paginationState.pageSize,
    initialPage: paginationState.page,
    query,
    variables,
    initialFilterModel: filterObj,
    initialSortModel: sortItems,
  });
} catch (error) {
  console.error('[useEnhancedDataGrid] Error setting up GraphQL data:', error);
  // Return empty/default state on error
  return {
    rows: [],
    totalRows: 0,
    loading: false,
    error,
    // Other default values...
  };
}
```

## Business Value

This architectural improvement delivers significant business value:

1. **Faster Development**: New data grids can be implemented in hours instead of days.

2. **Reduced Bugs**: Centralized implementation means bugs are fixed once for all instances.

3. **Consistent UX**: Users experience the same behavior across different parts of the application.

4. **Future-Proofing**: The architecture makes it easier to add new features or change the underlying implementation.

5. **Maintainability**: Clear separation of concerns makes the codebase more maintainable over time.

## Conclusion

Moving GraphQL fetching into the library component follows modern best practices in component library design. While it does reduce boilerplate code, the primary benefits are improved separation of concerns, better state management, enhanced reusability, and a significantly better developer experience.

This approach is similar to how industry-leading libraries like React Query, SWR, and Apollo Client have evolved to encapsulate data fetching logic, providing a clean API that hides implementation details while offering powerful features.


====== docs/enhanced-data-grid-implementation.md ======
Last Modified: 5/7/2025, 16:09 | Size: 2.0 KB | Lines: 59

# Enhanced Data Grid Implementation

## Accomplishments

1. **Created a Master Hook Architecture**
   - Implemented `useEnhancedDataGrid` hook that composes functionality from other hooks
   - Added support for conditional loading with `onlyLoadWithFilters` prop
   - Implemented enhanced column menu options

2. **Developed New UI Components**
   - Created `EmptyStateOverlay` for conditional loading UI
   - Implemented `GridToolbar` with dynamic mode-based actions
   - Ensured backward compatibility with existing code

3. **Implemented Main Component**
   - Created `EnhancedDataGrid` component with a clean, unified API
   - Maintained backward compatibility by aliasing to `EnhancedDataGridGraphQL`
   - Added proper TypeScript types and interfaces

4. **Added Comprehensive Tests**
   - Created tests for `useEnhancedDataGrid` hook
   - Set up testing infrastructure with Jest and React Testing Library
   - Fixed Jest configuration for proper TypeScript support

5. **Updated MTM Adjustments Page**
   - Integrated the new component with conditional loading
   - Added custom toolbar actions

## Next Steps

1. **Complete Testing**
   - Fix remaining tests for UI components
   - Add integration tests with real data

2. **Documentation**
   - Create comprehensive API documentation
   - Add usage examples for different scenarios

3. **Performance Optimization**
   - Profile and optimize rendering performance
   - Implement virtualization for large datasets

4. **Feature Enhancements**
   - Add support for custom cell renderers
   - Implement advanced filtering capabilities
   - Add export functionality

5. **Migration Plan**
   - Update all pages using the old component
   - Create migration guide for developers

## Technical Debt Addressed

- Consolidated scattered functionality into a single hook
- Improved type safety with proper TypeScript definitions
- Fixed testing infrastructure issues
- Standardized component API

This implementation provides a solid foundation for future enhancements while maintaining backward compatibility with existing code.


====== docs/master-hook-benefits.md ======
Last Modified: 5/7/2025, 15:36 | Size: 8.2 KB | Lines: 294

# Benefits of the Master Hook Approach

## How the Master Hook Adds Value and Simplifies the Code

The new master hook (`useEnhancedDataGrid`) provides several key benefits that will simplify the codebase and add flexibility:

### 1. Reduced Size and Complexity of the Main Component

**Current EnhancedDataGridGraphQL.tsx**: ~900 lines of code with complex state management logic mixed with component rendering.

**With Master Hook**: The main component could be reduced to ~400-500 lines, focusing primarily on rendering and component structure rather than state management logic.

### 2. Centralized State Management

**Current Approach**: State management is scattered across the main component with multiple useState calls, useEffect hooks, and complex conditional logic.

```typescript
// Current approach - scattered state management
const [internalPaginationModel, setInternalPaginationModel] = useState<GridPaginationModel>({...});
const [internalSortModel, setInternalSortModel] = useState<GridSortModel>([]);
const [internalFilterModel, setInternalFilterModel] = useState<GridFilterModel>({...});
const [currentPage, setCurrentPage] = useState(0);

// Multiple useEffect hooks to synchronize state
useEffect(() => { /* Synchronize pagination state */ }, [...]);
useEffect(() => { /* Synchronize sort state */ }, [...]);
useEffect(() => { /* Synchronize filter state */ }, [...]);
```

**With Master Hook**: State management is centralized in a single hook with clear responsibilities.

```typescript
// With master hook - centralized state management
const {
  columns,
  rows,
  totalRows,
  loading,
  error,
  filtersApplied,
  handleFilterModelChange,
  handleSortModelChange,
  handlePaginationModelChange,
  selectionState,
  paginationState,
  isEmpty,
  isLoadingWithoutFilters
} = useEnhancedDataGrid({...});
```

### 3. Better Separation of Concerns

**Current Approach**: The main component mixes concerns:
- State management
- Data fetching logic
- UI rendering
- Event handling
- Error handling

**With Master Hook**: Clear separation of concerns:
- **Master Hook**: State management, data fetching, event handling
- **Main Component**: UI rendering, component composition
- **UI Components**: Specific UI rendering responsibilities

### 4. Improved Testability

**Current Approach**: Testing the main component is difficult due to its size and mixed concerns.

**With Master Hook**: Each part can be tested independently:
- The master hook can be tested for state management logic
- The main component can be tested for rendering logic
- UI components can be tested for specific UI behaviors

### 5. Enhanced Flexibility

**Current Approach**: Adding new features requires modifying the main component, increasing its complexity.

**With Master Hook**: New features can be added to the hook without changing the main component's structure.

### 6. Code Reusability

**Current Approach**: Logic in the main component is tightly coupled to that component.

**With Master Hook**: The hook can be reused across different components or in different contexts.

## Specific Examples of Simplification

### Example 1: Pagination Logic

**Current Approach**:
```typescript
// Current approach - pagination logic in main component
const [internalPaginationModel, setInternalPaginationModel] = useState<GridPaginationModel>({
  page: 0,
  pageSize: pageSize,
});

const paginationModelToUse = useMemo(() => {
  return externalPaginationModel || internalPaginationModel;
}, [externalPaginationModel, internalPaginationModel]);

const handlePaginationModelChange = useCallback(
  (newModel: GridPaginationModel) => {
    if (!externalPaginationModel) {
      setInternalPaginationModel(newModel);
    }
    
    if (externalOnPaginationModelChange) {
      externalOnPaginationModelChange(newModel);
    }
    
    if (useGraphQLFetching && setPage) {
      setPage(newModel.page);
    }
  },
  [externalPaginationModel, externalOnPaginationModelChange, useGraphQLFetching]
);
```

**With Master Hook**:
```typescript
// With master hook - pagination logic handled by the hook
const {
  paginationState,
  handlePaginationModelChange
} = useEnhancedDataGrid({...});

// In the component, simply use the provided state and handler
<DataGrid
  paginationModel={paginationState.paginationModel}
  onPaginationModelChange={handlePaginationModelChange}
  // Other props
/>
```

### Example 2: GraphQL Data Fetching

**Current Approach**:
```typescript
// Current approach - complex GraphQL setup in main component
const selectGraphQLHook = useCallback(() => {
  if (!useGraphQLFetching) {
    return { /* Default empty state */ };
  }

  if (paginationStyle === 'key') {
    return useGraphQLData<T>({
      pageSize: paginationModelToUse.pageSize,
      initialPage: paginationModelToUse.page,
      query,
      variables,
      filterModel: filterModelToUse,
      sortModel: sortModelToUse,
      nodeToRow: (node) => ({
        ...node,
        id: node.accounting_mtm_history_id || node.id,
      }),
    });
  } else {
    return { /* Default empty state */ };
  }
}, [
  useGraphQLFetching,
  paginationStyle,
  paginationModelToUse.pageSize,
  paginationModelToUse.page,
  query,
  variables,
  filterModelToUse,
  sortModelToUse
]);

const graphQLResult = selectGraphQLHook();

const {
  rows: graphQLRows = [],
  totalRows: graphQLTotalRows = 0,
  loading: graphQLLoading = false,
  setPage = () => {},
  setSortModel = () => {},
  setFilterModel = () => {},
  refetch = () => Promise.resolve({ data: null }),
  pageInfo = { /* Default page info */ },
  resetCursors = () => {},
} = graphQLResult || {};
```

**With Master Hook**:
```typescript
// With master hook - GraphQL fetching handled by the hook
const {
  rows,
  totalRows,
  loading,
  error,
  refetch,
  resetCursors,
  pageInfo
} = useEnhancedDataGrid({
  useGraphQL: true,
  query,
  variables,
  // Other options
});

// In the component, simply use the provided data
<DataGrid
  rows={rows}
  loading={loading}
  // Other props
/>
```

## Error Handling and Logging Improvements

The master hook approach allows for more consistent and comprehensive error handling and logging:

### 1. Structured Logging

```typescript
// Consistent logging pattern
console.log('[useEnhancedDataGrid] Initializing with:', {
  columnsCount: columns?.length,
  rowsCount: rows?.length,
  useGraphQL,
  onlyLoadWithFilters
});

console.log('[useEnhancedDataGrid] Filter model changed:', newModel);
```

### 2. Comprehensive Error Handling

```typescript
// Try-catch blocks with specific error messages
try {
  return useGraphQLData<T>({
    // Configuration
  });
} catch (error) {
  console.error('[useEnhancedDataGrid] Error setting up GraphQL data:', error);
  // Return fallback state
  return {
    rows: [],
    totalRows: 0,
    loading: false,
    error,
    // Other fallback values
  };
}
```

### 3. Graceful Degradation

```typescript
// Graceful fallbacks when operations fail
const graphQLResult = useMemo(() => {
  if (!shouldFetchData) {
    console.log('[useEnhancedDataGrid] Skipping GraphQL fetch - conditions not met');
    return {
      // Default state when not fetching
    };
  }
  
  try {
    // Attempt to fetch data
  } catch (error) {
    // Handle error and provide fallback
  }
}, [/* dependencies */]);
```

## Renaming to EnhancedDataGrid.tsx

Renaming the main file from `EnhancedDataGridGraphQL.tsx` to `EnhancedDataGrid.tsx` makes sense because:

1. The component is becoming more general-purpose with the master hook
2. GraphQL is just one of the data fetching options, not the core identity
3. It simplifies the naming convention and makes it clearer that this is the main grid component

This change will require updating imports in any files that use the component, but the benefit of a clearer, more accurate name is worth it.

## Summary

The master hook approach will:

1. **Reduce Code Size**: Cut the main component size by ~40-50%
2. **Simplify Logic**: Centralize state management and data fetching
3. **Improve Flexibility**: Make it easier to add new features
4. **Enhance Testability**: Allow for better unit testing
5. **Provide Better Error Handling**: More consistent error handling and logging
6. **Maintain Familiarity**: Keep the same overall structure and API

These improvements align perfectly with the goals of adding more flexibility, simplicity, and power to the component.


====== docs/implementation-comparison.md ======
Last Modified: 5/7/2025, 15:31 | Size: 8.4 KB | Lines: 326

# Implementation Comparison: Existing vs. Enhanced DataGrid

This document compares the existing implementation of `EnhancedDataGridGraphQL.tsx` with the proposed enhanced implementation to ensure we maintain familiarity while adding new features.

## Core Structure Comparison

### Existing Implementation

The current implementation has these key components:

1. **Main Component**: `EnhancedDataGridGraphQL.tsx`
2. **Hooks**:
   - `useSelectionModel.ts`
   - `useRelayGraphQLData.ts`
   - `usePagination.ts`
3. **Context Providers**:
   - `GridFormContext.tsx`
   - `GridModeContext.tsx`
4. **Toolbar**: `UnifiedDataGridToolbar.tsx`

### Enhanced Implementation

The enhanced implementation maintains this structure while adding:

1. **New Master Hook**: `useEnhancedDataGrid.ts` (combines existing hooks)
2. **Improved Toolbar**: `GridToolbar.tsx` (better MUI integration)
3. **New Components**:
   - `EmptyStateOverlay.tsx` (for conditional loading)
4. **Extended Types**:
   - `columnConfig.ts` (adds menu options)

## Detailed Comparison

### 1. Main Component: EnhancedDataGridGraphQL.tsx

#### What Stays the Same:
- Component name and export pattern
- Props interface structure (we're just adding new props)
- Context providers wrapping pattern
- DataGrid component usage
- Core functionality for selection, pagination, filtering, and sorting

#### What Changes:
- Use of the new master hook instead of direct hook calls
- Simplified state management through the master hook
- Addition of conditional loading feature
- Use of the improved toolbar through slots system
- Addition of EmptyStateOverlay for conditional loading

```typescript
// BEFORE: Direct hook usage
const { selectionModel, onSelectionModelChange } = useSelectionModel({...});
const graphQLResult = useGraphQLData({...});

// AFTER: Master hook usage
const {
  columns,
  rows,
  totalRows,
  loading,
  error,
  filtersApplied,
  handleFilterModelChange,
  handleSortModelChange,
  handlePaginationModelChange,
  selectionState,
  paginationState,
  isEmpty,
  isLoadingWithoutFilters
} = useEnhancedDataGrid({...});
```

### 2. Hooks

#### What Stays the Same:
- All existing hooks remain unchanged
- Hook interfaces and return values are preserved
- Existing hook functionality is maintained

#### What Changes:
- Addition of a new master hook that composes existing hooks
- The master hook adds conditional loading logic
- Better coordination between hooks through the master hook

### 3. Context Providers

#### What Stays the Same:
- `GridFormContext` and `GridModeContext` remain unchanged
- Context usage patterns are preserved
- Context provider props are maintained

#### What Changes:
- No significant changes to context providers
- The master hook will interact with these contexts in a more coordinated way

### 4. Toolbar

#### What Stays the Same:
- Core functionality (add, save, cancel, selection indicators)
- Access to GridModeContext for state
- Support for custom actions

#### What Changes:
- Better integration with MUI X DataGrid's slots system
- Use of built-in MUI X toolbar components
- Simplified layout with logical sections
- Single component handling all modes instead of mode-specific components

```typescript
// BEFORE: Custom toolbar implementation
<UnifiedDataGridToolbar
  onSave={handleSave}
  onFilter={handleFilter}
  // Other props
/>

// AFTER: MUI X integrated toolbar
<DataGrid
  slots={{
    toolbar: GridToolbar,
    // Other slots
  }}
  slotProps={{
    toolbar: {
      customActions: customToolbarActions,
      onFilterClick: handleOpenFilterPanel
    },
    // Other slot props
  }}
/>
```

## New Features Comparison

### 1. Conditional Loading

This is a completely new feature that doesn't exist in the current implementation. It allows the grid to only load data when filters are applied.

```typescript
// New prop
onlyLoadWithFilters={true}

// Implementation in master hook
const shouldFetchData = useMemo(() => {
  if (!useGraphQLFetching) return false;
  if (!onlyLoadWithFilters) return true;
  return filtersApplied;
}, [useGraphQLFetching, onlyLoadWithFilters, filtersApplied]);
```

### 2. Enhanced Column Menus

This is a new feature that extends the column configuration to support customizable menu options.

```typescript
// New column configuration
{
  field: 'name',
  headerName: 'Name',
  menuOptions: {
    showSortAsc: true,
    showSortDesc: true,
    showFilter: true,
    customItems: [
      {
        label: 'Custom Action',
        onClick: (colDef) => { /* Custom action */ }
      }
    ]
  }
}
```

### 3. Improved Error Handling

The enhanced implementation adds more comprehensive error handling and logging.

```typescript
// BEFORE: Basic error handling
if (error) {
  console.error('Error:', error);
}

// AFTER: Structured logging and error handling
console.log('[useEnhancedDataGrid] Initializing with:', {
  columnsCount: columns?.length,
  rowsCount: rows?.length,
  useGraphQL,
  onlyLoadWithFilters
});

try {
  // Operation
} catch (error) {
  console.error('[useEnhancedDataGrid] Error:', error);
  // Fallback behavior
}
```

## Code Structure Comparison

### File Structure

#### Existing Structure:
```
components/
└── DataGrid/
    ├── index.ts
    ├── EnhancedDataGridGraphQL.tsx
    ├── hooks/
    │   ├── useSelectionModel.ts
    │   ├── useRelayGraphQLData.ts
    │   └── ...
    ├── context/
    │   ├── GridFormContext.tsx
    │   ├── GridModeContext.tsx
    │   └── ...
    ├── components/
    │   ├── UnifiedDataGridToolbar.tsx
    │   └── ...
```

#### Enhanced Structure:
```
components/
└── DataGrid/
    ├── index.ts
    ├── EnhancedDataGridGraphQL.tsx
    ├── hooks/
    │   ├── useEnhancedDataGrid.ts  (NEW)
    │   ├── useSelectionModel.ts
    │   ├── useRelayGraphQLData.ts
    │   └── ...
    ├── context/
    │   ├── GridFormContext.tsx
    │   ├── GridModeContext.tsx
    │   └── ...
    ├── components/
    │   ├── GridToolbar.tsx  (REPLACES UnifiedDataGridToolbar.tsx)
    │   ├── EmptyStateOverlay.tsx  (NEW)
    │   └── ...
    └── types/
        ├── columnConfig.ts  (NEW)
        └── ...
```

The enhanced structure maintains the same organization while adding new files for new features.

## Component Usage Comparison

### Current Usage:

```tsx
<EnhancedDataGridGraphQL
  columns={columns}
  rows={data}
  onSave={handleSave}
  validateRow={validateRow}
  useGraphQL={true}
  query={QUERY}
  variables={variables}
  checkboxSelection={true}
  selectionModel={selectionModel}
  onSelectionModelChange={handleSelectionChange}
  canEditRows={true}
  canAddRows={true}
  canSelectRows={true}
  density="standard"
  disableSelectionOnClick={true}
  pageSize={25}
  rowsPerPageOptions={[10, 25, 50, 100]}
/>
```

### Enhanced Usage:

```tsx
<EnhancedDataGridGraphQL
  columns={columns}
  rows={data}
  onSave={handleSave}
  validateRow={validateRow}
  useGraphQL={true}
  query={QUERY}
  variables={variables}
  // New props
  onlyLoadWithFilters={true}
  customToolbarActions={<CustomActions />}
  // Existing props
  checkboxSelection={true}
  selectionModel={selectionModel}
  onSelectionModelChange={handleSelectionChange}
  canEditRows={true}
  canAddRows={true}
  canSelectRows={true}
  density="standard"
  disableSelectionOnClick={true}
  pageSize={25}
  rowsPerPageOptions={[10, 25, 50, 100]}
/>
```

The enhanced usage maintains backward compatibility while adding new optional props.

## Summary of Changes

### What We're Keeping:
1. Overall component structure and organization
2. Existing hooks and their functionality
3. Context providers and their usage patterns
4. Core DataGrid functionality (selection, pagination, filtering, sorting)
5. Prop interface structure (just adding new props)

### What We're Changing:
1. Adding a master hook for better state management
2. Replacing the custom toolbar with a MUI X integrated toolbar
3. Adding conditional loading feature
4. Extending column configuration for menu customization
5. Improving error handling and logging

### What We're Adding:
1. EmptyStateOverlay component for conditional loading
2. Enhanced column menu options
3. Better MUI X integration through slots system

The enhanced implementation maintains familiarity with the existing code while adding new features and improving integration with MUI X DataGrid. The changes are focused on adding functionality rather than restructuring the existing code.


====== docs/updated-implementation-plan.md ======
Last Modified: 5/7/2025, 15:28 | Size: 13.2 KB | Lines: 416

# Updated Enhanced Data Grid Implementation Plan

Based on our discussion and analysis of the existing codebase, this document outlines the revised implementation plan for enhancing the DataGrid component with a new master hook and improved UI components that better integrate with MUI X DataGrid.

## File Structure Overview

```
components/
└── DataGrid/
    ├── index.ts                            // Main export file (existing)
    ├── EnhancedDataGridGraphQL.tsx         // Main component (existing, to be modified)
    ├── hooks/
    │   ├── index.ts                        // Hook exports (existing, to be updated)
    │   ├── useEnhancedDataGrid.ts          // New master hook (to be created)
    │   ├── useGraphQLData.ts               // Existing hook
    │   ├── useSelectionModel.ts            // Existing hook
    │   └── ...                             // Other existing hooks
    ├── context/
    │   ├── GridFormContext.tsx             // Existing context
    │   ├── GridModeContext.tsx             // Existing context
    │   └── ...                             // Other existing contexts
    ├── components/
    │   ├── GridToolbar.tsx                 // New unified toolbar component (to be created)
    │   ├── EmptyStateOverlay.tsx           // New component (to be created)
    │   ├── CustomColumnMenu.tsx            // New component (to be created)
    │   └── ...                             // Existing components
    └── types/
        ├── index.ts                        // Type exports (existing)
        ├── columnConfig.ts                 // Extended column types (to be created)
        └── ...                             // Other existing type files
```

## Implementation Steps

### 1. Create the Master Hook: `useEnhancedDataGrid.ts`

This will be a composition hook that combines functionality from other hooks while adding new features.

```typescript
// hooks/useEnhancedDataGrid.ts
import { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import { GridFilterModel, GridSortModel, GridRowId } from '@mui/x-data-grid';
import { useGraphQLData } from './useRelayGraphQLData';
import { useSelectionModel } from './useSelectionModel';
import { usePagination } from './usePagination';
import { EnhancedColumnConfig } from '../EnhancedDataGridGraphQL';

// Interface definitions and implementation as in the original plan
// ...
```

### 2. Create the New UI Components

#### a. EmptyStateOverlay Component

```typescript
// components/EmptyStateOverlay.tsx
import React from 'react';
import { Typography, Button, Box } from '@mui/material';
import FilterAltIcon from '@mui/icons-material/FilterAlt';

interface EmptyStateOverlayProps {
  onFilterClick?: () => void;
}

export const EmptyStateOverlay: React.FC<EmptyStateOverlayProps> = ({ 
  onFilterClick 
}) => {
  return (
    <Box 
      sx={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 4
      }}
    >
      <FilterAltIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
      <Typography variant="h6">No Results to Display</Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2, textAlign: 'center' }}>
        Apply filters to load data for this grid
      </Typography>
      {onFilterClick && (
        <Button 
          variant="outlined" 
          startIcon={<FilterAltIcon />} 
          onClick={onFilterClick}
          size="small"
        >
          Open Filters
        </Button>
      )}
    </Box>
  );
};
```

#### b. Unified MUI-Integrated Toolbar Component

```typescript
// components/GridToolbar.tsx
import React from 'react';
import { 
  GridToolbarContainer, 
  GridToolbarColumnsButton,
  GridToolbarFilterButton,
  GridToolbarDensitySelector,
  GridToolbarExportButton,
  GridToolbarProps as MuiGridToolbarProps
} from '@mui/x-data-grid';
import { Button, Chip, Divider, Box } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import SaveIcon from '@mui/icons-material/Save';
import CloseIcon from '@mui/icons-material/Close';
import DeleteIcon from '@mui/icons-material/Delete';
import { useGridMode } from '../context/GridModeContext';

export interface GridToolbarProps extends MuiGridToolbarProps {
  customActions?: React.ReactNode;
  onFilterClick?: () => void;
}

export const GridToolbar = React.forwardRef<HTMLDivElement, GridToolbarProps>((props, ref) => {
  const { 
    mode,
    addRow, 
    saveChanges,
    cancelChanges,
    selectionModel, 
    clearSelection, 
    deleteRows,
    canAddRows,
    canDeleteRows,
    hasValidationErrors,
    isAddingRow,
    editingRowCount
  } = useGridMode();
  
  const { customActions, onFilterClick, ...other } = props;
  
  // Handle filter button click
  const handleFilterClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    if (onFilterClick) {
      onFilterClick();
    }
    // Call the original handler if it exists
    if (other.onClick) {
      other.onClick(event);
    }
  };
  
  return (
    <GridToolbarContainer ref={ref} {...other}>
      {/* Left section: Standard MUI X toolbar buttons */}
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <GridToolbarColumnsButton />
        <GridToolbarFilterButton onClick={handleFilterClick} />
        <GridToolbarDensitySelector />
        <GridToolbarExportButton />
      </Box>
      
      <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
      
      {/* Middle section: Mode-specific actions */}
      <Box sx={{ display: 'flex', alignItems: 'center', flexGrow: 1 }}>
        {/* Edit/Add mode actions */}
        {(mode === 'edit' || mode === 'add') && (
          <>
            <Button 
              startIcon={<SaveIcon />} 
              onClick={saveChanges}
              disabled={hasValidationErrors}
              color="primary"
              size="small"
            >
              {isAddingRow ? 'Add' : 'Save'}
            </Button>
            
            <Button 
              startIcon={<CloseIcon />} 
              onClick={cancelChanges}
              size="small"
              sx={{ ml: 1 }}
            >
              Cancel
            </Button>
            
            {/* Status indicators */}
            {isAddingRow ? (
              <Chip 
                label="Adding new record" 
                color="success" 
                size="small" 
                sx={{ ml: 2 }}
              />
            ) : editingRowCount > 0 && (
              <Chip 
                label={`Editing ${editingRowCount} record(s)`} 
                color="primary" 
                size="small" 
                sx={{ ml: 2 }}
              />
            )}
            
            {hasValidationErrors && (
              <Chip 
                label="Fix validation errors" 
                color="error" 
                size="small"
                sx={{ ml: 1 }}
              />
            )}
          </>
        )}
        
        {/* View mode actions */}
        {mode === 'none' && canAddRows && (
          <Button 
            startIcon={<AddIcon />} 
            onClick={addRow}
            size="small"
          >
            Add
          </Button>
        )}
        
        {/* Selection mode actions */}
        {selectionModel.length > 0 && (
          <>
            <Chip 
              label={`${selectionModel.length} selected`}
              onDelete={clearSelection}
              size="small"
              sx={{ ml: mode !== 'none' ? 2 : 0 }}
            />
            
            {canDeleteRows && mode !== 'edit' && mode !== 'add' && (
              <Button
                startIcon={<DeleteIcon />}
                onClick={() => deleteRows(selectionModel)}
                color="error"
                size="small"
                sx={{ ml: 1 }}
              >
                Delete
              </Button>
            )}
          </>
        )}
      </Box>
      
      {/* Right section: Custom actions */}
      {customActions && (
        <>
          <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {customActions}
          </Box>
        </>
      )}
    </GridToolbarContainer>
  );
});
```

### 3. Update Type Definitions

```typescript
// types/columnConfig.ts
import { GridColDef } from '@mui/x-data-grid';

// Add menu options to column config
export interface EnhancedColumnConfig<T = any> extends Omit<GridColDef, 'renderCell' | 'renderEditCell'> {
  // Existing properties and new menuOptions as in the original plan
  // ...
}
```

### 4. Update Main Component to Use New Features

```typescript
// EnhancedDataGridGraphQL.tsx (modified)
import React, { useCallback } from 'react';
import { DataGrid, GridFilterModel } from '@mui/x-data-grid';
import { useEnhancedDataGrid } from './hooks/useEnhancedDataGrid';
import { GridFormProvider } from './context/GridFormContext';
import { GridModeProvider } from './context/GridModeContext';
import { GridToolbar } from './components/GridToolbar';
import { EmptyStateOverlay } from './components/EmptyStateOverlay';

// Keep existing interfaces and add new props
export interface EnhancedDataGridGraphQLProps<T = any> {
  // Existing props...
  
  // New props
  onlyLoadWithFilters?: boolean;
  customToolbarActions?: React.ReactNode;
}

export function EnhancedDataGridGraphQL<T extends { id: GridRowId }>({
  // Add new props
  onlyLoadWithFilters = false,
  customToolbarActions,
  // Existing props
  ...props
}) {
  // Implementation as in the original plan, but using the new GridToolbar
  // ...
  
  return (
    <GridFormProvider>
      <GridModeProvider>
        <DataGrid
          // ...other props
          slots={{
            toolbar: GridToolbar,
            noRowsOverlay: isLoadingWithoutFilters ? EmptyStateOverlay : undefined,
            // Other slots
          }}
          slotProps={{
            toolbar: {
              customActions: customToolbarActions,
              onFilterClick: handleOpenFilterPanel
            },
            // Other slot props
          }}
        />
      </GridModeProvider>
    </GridFormProvider>
  );
}
```

### 5. Update Hook Exports

```typescript
// hooks/index.ts (updated)
export * from './useGridNavigation';
export * from './useGridValidation';
export * from './useServerSideData';
export * from './useRelayGraphQLData';
export * from './useSelectionModel';
export * from './usePagination';
export * from './useEnhancedDataGrid'; // Add the new hook export
```

## Usage Example

```typescript
// MTMAdjustmentsPage.tsx (example usage)
import React, { useState } from 'react';
import { GridRowId } from '@mui/x-data-grid';
import { Paper, Button } from '@mui/material';
import BarChartIcon from '@mui/icons-material/BarChart';
import { gql } from '@apollo/client';
import { EnhancedDataGridGraphQL } from '../components/DataGrid';
import { ValidationHelpers } from '../components/DataGrid/context/GridFormContext';

// Custom toolbar actions
const CustomActions = () => {
  const handleAnalyticsClick = () => {
    console.log('Show analytics for current data');
    // Analytics logic
  };
  
  return (
    <Button
      startIcon={<BarChartIcon />}
      onClick={handleAnalyticsClick}
      size="small"
    >
      Analytics
    </Button>
  );
};

export default function MTMAdjustmentsPage() {
  // Implementation as in the original plan
  // ...
}
```

## Key Improvements in This Updated Plan

1. **Better MUI X Integration**: The toolbar now uses the built-in MUI X DataGrid components and slots system
2. **Simplified Component Structure**: Single unified toolbar component instead of multiple mode-specific components
3. **Improved Flexibility**: The toolbar handles all grid modes in one component
4. **Consistent Design**: Maintains the MUI X look and feel
5. **Enhanced Extensibility**: Easy to add new functionality through the slots and props system

## Implementation Sequence

To implement this plan effectively, we should follow this sequence:

1. Create the type definitions first (`columnConfig.ts`)
2. Implement the master hook (`useEnhancedDataGrid.ts`)
3. Create the UI components (EmptyStateOverlay and GridToolbar)
4. Update the main component to use the new features
5. Update the hook exports
6. Test with an example page

## Summary

This updated implementation plan maintains the core functionality of the original plan while improving the toolbar implementation to better integrate with MUI X DataGrid. The unified toolbar approach provides better flexibility and simplicity, addressing the concerns about the previous UnifiedDataGridToolbar implementation.

The key benefits of this implementation remain:

- **Conditional Loading**: Allows grids to only load data when filters are applied
- **Unified Interface**: Provides a single hook that manages all grid state
- **Improved Toolbar**: Context-aware toolbar that integrates with MUI X
- **Enhanced Column Menus**: Customizable column menu options
- **Better Error Handling**: Comprehensive error handling and logging

This implementation follows the principle of progressive enhancement, allowing existing code to continue working while providing new capabilities for future development.


====== docs/mui-integrated-toolbar-approach.md ======
Last Modified: 5/7/2025, 15:27 | Size: 7.4 KB | Lines: 238

# MUI X DataGrid Integrated Toolbar Approach

## Understanding MUI X DataGrid's Toolbar System

MUI X DataGrid has a built-in slots system that allows for customizing components like the toolbar. The DataGrid provides:

1. `GridToolbarContainer` - A container component for toolbar items
2. Built-in toolbar components:
   - `GridToolbarColumnsButton` - For column visibility
   - `GridToolbarFilterButton` - For filtering
   - `GridToolbarDensitySelector` - For density selection
   - `GridToolbarExportButton` - For exporting data
3. A default `GridToolbar` that combines these components

The DataGrid uses a slot-based customization approach where you can provide your own components for various parts of the grid.

## Improved Toolbar Integration

Instead of creating a completely custom toolbar that replaces the MUI X functionality, we can extend the built-in toolbar system:

1. Use the `slots` and `slotProps` pattern that MUI X DataGrid provides
2. Create a toolbar component that leverages the built-in toolbar components
3. Add our custom functionality while maintaining the MUI X look and feel

### Implementation Approach

```typescript
// components/DataGrid/components/GridToolbar.tsx
import React from 'react';
import { 
  GridToolbarContainer, 
  GridToolbarColumnsButton,
  GridToolbarFilterButton,
  GridToolbarDensitySelector,
  GridToolbarExportButton,
  GridToolbarProps as MuiGridToolbarProps
} from '@mui/x-data-grid';
import { Button, Chip, Divider, Box } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import SaveIcon from '@mui/icons-material/Save';
import CloseIcon from '@mui/icons-material/Close';
import DeleteIcon from '@mui/icons-material/Delete';
import { useGridMode } from '../context/GridModeContext';

export interface GridToolbarProps extends MuiGridToolbarProps {
  customActions?: React.ReactNode;
  onFilterClick?: () => void;
}

export const GridToolbar = React.forwardRef<HTMLDivElement, GridToolbarProps>((props, ref) => {
  const { 
    mode,
    addRow, 
    saveChanges,
    cancelChanges,
    selectionModel, 
    clearSelection, 
    deleteRows,
    canAddRows,
    canDeleteRows,
    hasValidationErrors,
    isAddingRow,
    editingRowCount
  } = useGridMode();
  
  const { customActions, onFilterClick, ...other } = props;
  
  // Handle filter button click
  const handleFilterClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    if (onFilterClick) {
      onFilterClick();
    }
    // Call the original handler if it exists
    if (other.onClick) {
      other.onClick(event);
    }
  };
  
  return (
    <GridToolbarContainer ref={ref} {...other}>
      {/* Left section: Standard MUI X toolbar buttons */}
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <GridToolbarColumnsButton />
        <GridToolbarFilterButton onClick={handleFilterClick} />
        <GridToolbarDensitySelector />
        <GridToolbarExportButton />
      </Box>
      
      <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
      
      {/* Middle section: Mode-specific actions */}
      <Box sx={{ display: 'flex', alignItems: 'center', flexGrow: 1 }}>
        {/* Edit/Add mode actions */}
        {(mode === 'edit' || mode === 'add') && (
          <>
            <Button 
              startIcon={<SaveIcon />} 
              onClick={saveChanges}
              disabled={hasValidationErrors}
              color="primary"
              size="small"
            >
              {isAddingRow ? 'Add' : 'Save'}
            </Button>
            
            <Button 
              startIcon={<CloseIcon />} 
              onClick={cancelChanges}
              size="small"
              sx={{ ml: 1 }}
            >
              Cancel
            </Button>
            
            {/* Status indicators */}
            {isAddingRow ? (
              <Chip 
                label="Adding new record" 
                color="success" 
                size="small" 
                sx={{ ml: 2 }}
              />
            ) : editingRowCount > 0 && (
              <Chip 
                label={`Editing ${editingRowCount} record(s)`} 
                color="primary" 
                size="small" 
                sx={{ ml: 2 }}
              />
            )}
            
            {hasValidationErrors && (
              <Chip 
                label="Fix validation errors" 
                color="error" 
                size="small"
                sx={{ ml: 1 }}
              />
            )}
          </>
        )}
        
        {/* View mode actions */}
        {mode === 'none' && canAddRows && (
          <Button 
            startIcon={<AddIcon />} 
            onClick={addRow}
            size="small"
          >
            Add
          </Button>
        )}
        
        {/* Selection mode actions */}
        {selectionModel.length > 0 && (
          <>
            <Chip 
              label={`${selectionModel.length} selected`}
              onDelete={clearSelection}
              size="small"
              sx={{ ml: mode !== 'none' ? 2 : 0 }}
            />
            
            {canDeleteRows && mode !== 'edit' && mode !== 'add' && (
              <Button
                startIcon={<DeleteIcon />}
                onClick={() => deleteRows(selectionModel)}
                color="error"
                size="small"
                sx={{ ml: 1 }}
              >
                Delete
              </Button>
            )}
          </>
        )}
      </Box>
      
      {/* Right section: Custom actions */}
      {customActions && (
        <>
          <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {customActions}
          </Box>
        </>
      )}
    </GridToolbarContainer>
  );
});
```

## Integration with DataGrid

```typescript
// In EnhancedDataGridGraphQL.tsx
<DataGrid
  // ...other props
  slots={{
    toolbar: GridToolbar,
    noRowsOverlay: isLoadingWithoutFilters ? EmptyStateOverlay : undefined,
    // Other slots
  }}
  slotProps={{
    toolbar: {
      customActions: customToolbarActions,
      onFilterClick: handleOpenFilterPanel
    },
    // Other slot props
  }}
/>
```

## Benefits of This Approach

1. **Better MUI X Integration**: Uses the built-in slots system and toolbar components
2. **Maintains MUI X Look and Feel**: Preserves the standard MUI X toolbar buttons
3. **Flexible Layout**: Divides the toolbar into logical sections (standard buttons, mode-specific actions, custom actions)
4. **Simplified Implementation**: Single component handles all modes
5. **Extensible**: Easy to add new functionality or customize existing behavior

## Comparison with Previous Approach

The previous `UnifiedDataGridToolbar.tsx` had several issues:

1. **Complex Layout**: Used nested Box components with complex styling
2. **Manual Implementation**: Reimplemented functionality already provided by MUI X
3. **Inconsistent Look and Feel**: Didn't match the MUI X design language
4. **Limited Extensibility**: Difficult to add new features or customize behavior

The new approach addresses these issues by:

1. **Leveraging MUI X Components**: Uses built-in toolbar components
2. **Simplified Layout**: Clear, logical sections with minimal nesting
3. **Consistent Design**: Matches the MUI X design language
4. **Improved Extensibility**: Easy to customize through props and slots

This approach provides the flexibility and simplicity you're looking for while integrating better with the MUI X Grid way of doing things.


====== docs/toolbar-modes-explanation.md ======
Last Modified: 5/7/2025, 15:22 | Size: 6.3 KB | Lines: 215

# Toolbar Modes Explanation

## Current Approach in the Implementation Plan

In the current implementation plan, I've separated the toolbar into two components:

1. **EditModeToolbar**: Shown when the grid is in edit or add mode
2. **ViewModeToolbar**: Shown when the grid is in view mode

You're absolutely right that this approach doesn't fully account for all possible states of the grid, particularly selection mode. The current GridModeContext defines several modes:

```typescript
export type GridMode = 'none' | 'edit' | 'add' | 'select';
```

## Issues with the Current Approach

1. **Incomplete Mode Coverage**: The current implementation only handles 'edit'/'add' vs. other modes, but doesn't specifically address 'select' mode
2. **Redundant Components**: Having separate components for each mode could lead to code duplication
3. **Limited Flexibility**: If we add more modes in the future, we'd need to create more toolbar components

## Improved Approach: Single Dynamic Toolbar

A better approach would be to have a single `GridToolbar` component that dynamically renders different controls based on the current mode. This would:

1. Eliminate the need for separate toolbar components
2. Handle all possible grid modes in one place
3. Be more maintainable and flexible

### Example Implementation:

```typescript
// components/GridToolbar.tsx
import React from 'react';
import { 
  GridToolbarContainer, 
  GridToolbarFilterButton,
  GridToolbarColumnsButton,
  GridToolbarExportButton
} from '@mui/x-data-grid';
import { Button, Chip } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import SaveIcon from '@mui/icons-material/Save';
import CloseIcon from '@mui/icons-material/Close';
import DeleteIcon from '@mui/icons-material/Delete';
import { useGridMode } from '../context/GridModeContext';

export interface GridToolbarProps {
  customActions?: React.ReactNode;
  onFilterClick?: () => void;
}

export const GridToolbar = React.forwardRef<HTMLDivElement, GridToolbarProps>((props, ref) => {
  const { 
    mode,
    addRow, 
    saveChanges,
    cancelChanges,
    selectionModel, 
    clearSelection, 
    deleteRows,
    canAddRows,
    canDeleteRows,
    hasValidationErrors,
    isAddingRow,
    editingRowCount
  } = useGridMode();
  
  const { customActions, onFilterClick } = props;
  
  // Determine which controls to show based on mode
  const showAddButton = canAddRows && mode !== 'edit' && mode !== 'add';
  const showSaveButton = mode === 'edit' || mode === 'add';
  const showCancelButton = mode === 'edit' || mode === 'add';
  const showSelectionChip = selectionModel.length > 0;
  const showDeleteButton = canDeleteRows && selectionModel.length > 0 && mode !== 'edit' && mode !== 'add';
  const showEditingStatus = mode === 'edit' || mode === 'add';
  
  // Determine action label based on mode
  const actionLabel = isAddingRow ? 'Add' : 'Save';
  
  return (
    <GridToolbarContainer ref={ref}>
      {/* Standard DataGrid toolbar buttons */}
      <GridToolbarFilterButton onClick={onFilterClick} />
      <GridToolbarColumnsButton />
      <GridToolbarExportButton />
      
      {/* Add button */}
      {showAddButton && (
        <Button 
          startIcon={<AddIcon />} 
          onClick={addRow}
          size="small"
        >
          Add
        </Button>
      )}
      
      {/* Save button for edit/add mode */}
      {showSaveButton && (
        <Button 
          startIcon={<SaveIcon />} 
          onClick={saveChanges}
          disabled={hasValidationErrors}
          color="primary"
          size="small"
        >
          {actionLabel}
        </Button>
      )}
      
      {/* Cancel button for edit/add mode */}
      {showCancelButton && (
        <Button 
          startIcon={<CloseIcon />} 
          onClick={cancelChanges}
          size="small"
        >
          Cancel
        </Button>
      )}
      
      {/* Status indicators */}
      {showEditingStatus && (
        <>
          {isAddingRow ? (
            <Chip 
              label="Adding new record" 
              color="success" 
              size="small" 
              sx={{ ml: 2 }}
            />
          ) : editingRowCount > 0 && (
            <Chip 
              label={`Editing ${editingRowCount} record(s)`} 
              color="primary" 
              size="small" 
              sx={{ ml: 2 }}
            />
          )}
          
          {hasValidationErrors && (
            <Chip 
              label="Fix validation errors" 
              color="error" 
              size="small"
              sx={{ ml: 1 }}
            />
          )}
        </>
      )}
      
      {/* Selection indicator */}
      {showSelectionChip && (
        <Chip 
          label={`${selectionModel.length} selected`}
          onDelete={clearSelection}
          size="small"
          sx={{ ml: 2 }}
        />
      )}
      
      {/* Delete button for selection mode */}
      {showDeleteButton && (
        <Button
          startIcon={<DeleteIcon />}
          onClick={() => deleteRows(selectionModel)}
          color="error"
          size="small"
          sx={{ ml: 1 }}
        >
          Delete
        </Button>
      )}
      
      {/* Custom actions */}
      {customActions}
    </GridToolbarContainer>
  );
});
```

## Benefits of the Unified Approach

1. **Comprehensive Mode Handling**: Handles all grid modes in one component
2. **Reduced Code Duplication**: No need for separate components with similar code
3. **Improved Maintainability**: Changes to toolbar behavior only need to be made in one place
4. **Better Flexibility**: Easy to add support for new modes or states
5. **Contextual Controls**: Shows only the relevant controls for each mode

## Implementation in the Main Component

With this approach, the main component would simply use the unified `GridToolbar`:

```typescript
// In EnhancedDataGridGraphQL.tsx
<DataGrid
  // ...other props
  slots={{
    toolbar: GridToolbar,
    noRowsOverlay: isLoadingWithoutFilters ? EmptyStateOverlay : undefined,
    // Other slots
  }}
  slotProps={{
    toolbar: {
      customActions: customToolbarActions,
      onFilterClick: handleOpenFilterPanel
    },
    // Other slot props
  }}
/>
```

This approach aligns better with the existing `GridModeContext` and provides a more flexible solution for handling all the different states of the grid.


====== docs/enhanced-data-grid-implementation-plan.md ======
Last Modified: 5/7/2025, 11:59 | Size: 30.2 KB | Lines: 987

# Enhanced Data Grid Implementation Plan

Based on a thorough analysis of the existing codebase, this document outlines the detailed implementation plan for enhancing the DataGrid component with a new master hook and additional UI components.

## File Structure Overview

```
components/
└── DataGrid/
    ├── index.ts                            // Main export file (existing)
    ├── EnhancedDataGridGraphQL.tsx         // Main component (existing, to be modified)
    ├── hooks/
    │   ├── index.ts                        // Hook exports (existing, to be updated)
    │   ├── useEnhancedDataGrid.ts          // New master hook (to be created)
    │   ├── useGraphQLData.ts               // Existing hook
    │   ├── useSelectionModel.ts            // Existing hook
    │   └── ...                             // Other existing hooks
    ├── context/
    │   ├── GridFormContext.tsx             // Existing context
    │   ├── GridModeContext.tsx             // Existing context
    │   └── ...                             // Other existing contexts
    ├── components/
    │   ├── toolbar/                        // New folder for toolbar components
    │   │   ├── DynamicToolbar.tsx          // New component (to be created)
    │   │   ├── EditModeToolbar.tsx         // New component (to be created)
    │   │   └── ViewModeToolbar.tsx         // New component (to be created)
    │   ├── EmptyStateOverlay.tsx           // New component (to be created)
    │   ├── CustomColumnMenu.tsx            // New component (to be created)
    │   └── ...                             // Existing components
    └── types/
        ├── index.ts                        // Type exports (existing)
        ├── columnConfig.ts                 // Extended column types (to be created)
        └── ...                             // Other existing type files
## Implementation Steps

### 1. Create the Master Hook: `useEnhancedDataGrid.ts`

This will be a composition hook that combines functionality from other hooks while adding new features.

```typescript
// hooks/useEnhancedDataGrid.ts
import { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import { GridFilterModel, GridSortModel, GridRowId } from '@mui/x-data-grid';
import { useGraphQLData } from './useRelayGraphQLData';
import { useSelectionModel } from './useSelectionModel';
import { usePagination } from './usePagination';
import { EnhancedColumnConfig } from '../EnhancedDataGridGraphQL';

export interface EnhancedDataGridHookOptions<T = any> {
  // Base props
  columns: EnhancedColumnConfig[];
  rows: T[];
  
  // GraphQL options
  useGraphQL?: boolean;
  forceClientSide?: boolean;
  query?: any;
  variables?: Record<string, any>;
  paginationStyle?: 'cursor' | 'offset' | 'key';
  
  // New feature: conditional loading
  onlyLoadWithFilters?: boolean;
  
  // Pagination options
  pageSize?: number;
  initialPage?: number;
  paginationMode?: 'client' | 'server';
  
  // Sorting and filtering options
  sortModel?: GridSortModel;
  onSortModelChange?: (model: GridSortModel) => void;
  sortingMode?: 'client' | 'server';
  filterModel?: GridFilterModel;
  onFilterModelChange?: (model: GridFilterModel) => void;
  filterMode?: 'client' | 'server';
  
  // Selection options
  selectionModel?: GridRowId[];
  onSelectionModelChange?: (selectionModel: GridRowId[]) => void;
  
  // Other options
  loading?: boolean;
}

export interface EnhancedDataGridHookResult<T = any> {
  // Grid configuration
  columns: EnhancedColumnConfig[];
  rows: T[];
  totalRows: number;
  loading: boolean;
  error: Error | null;
  
  // State tracking
  filtersApplied: boolean;
  
  // Event handlers
  handleFilterModelChange: (model: GridFilterModel) => void;
  handleSortModelChange: (model: GridSortModel) => void;
  handlePaginationModelChange: (model: any) => void;
  
  // Hooks state
  selectionState: any;
  paginationState: any;
  
  // GraphQL utilities
  refetch: () => Promise<any>;
  resetCursors: () => void;
  pageInfo: any;
  
  // Component flags
  isEmpty: boolean;
  isLoadingWithoutFilters: boolean;
}
```
```typescript
export function useEnhancedDataGrid<T extends { id: GridRowId }>({
  // Base props
  columns,
  rows,
  // GraphQL options
  useGraphQL = true,
  forceClientSide = false,
  query,
  variables,
  paginationStyle = 'cursor',
  // New feature: conditional loading
  onlyLoadWithFilters = false,
  // Pagination options
  pageSize = 25,
  initialPage = 0,
  paginationMode = 'server',
  // Sorting and filtering options
  sortModel: initialSortModel,
  onSortModelChange: externalOnSortModelChange,
  sortingMode = 'server',
  filterModel: initialFilterModel,
  onFilterModelChange: externalOnFilterModelChange,
  filterMode = 'server',
  // Selection options
  selectionModel: initialSelectionModel,
  onSelectionModelChange,
  // Other options
  loading: externalLoading = false,
}: EnhancedDataGridHookOptions<T>): EnhancedDataGridHookResult<T> {
  console.log('[useEnhancedDataGrid] Initializing with:', {
    columnsCount: columns?.length,
    rowsCount: rows?.length,
    useGraphQL,
    onlyLoadWithFilters
  });
  
  // State for tracking if filters have been applied
  const [filtersApplied, setFiltersApplied] = useState(false);
  
  // Determine if GraphQL fetching should be used
  const useGraphQLFetching = useMemo(
    () => useGraphQL && !forceClientSide,
    [useGraphQL, forceClientSide]
  );
  
  // Setup filter and sort models with proper state tracking
  const [internalFilterModel, setInternalFilterModel] = useState<GridFilterModel>(
    initialFilterModel || { items: [] }
  );
  const [internalSortModel, setInternalSortModel] = useState<GridSortModel>(
    initialSortModel || []
  );
  
  // Use appropriate hooks based on configuration
  const selectionState = useSelectionModel({
    selectionModel: initialSelectionModel,
    onSelectionModelChange,
  });
  
  const paginationState = usePagination({
    initialPage,
    initialPageSize: pageSize,
  });
  
  // Determine if data should be fetched
  const shouldFetchData = useMemo(() => {
    if (!useGraphQLFetching) return false;
    if (!onlyLoadWithFilters) return true;
    return filtersApplied;
  }, [useGraphQLFetching, onlyLoadWithFilters, filtersApplied]);
  
  // Setup GraphQL data with conditional fetching
  const graphQLResult = useMemo(() => {
    if (!shouldFetchData) {
      console.log('[useEnhancedDataGrid] Skipping GraphQL fetch - conditions not met');
      return {
        rows: [],
        totalRows: 0,
        loading: false,
        error: null,
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false, 
          startCursor: null,
          endCursor: null
        },
        setPage: () => {},
        setSortModel: () => {},
        setFilterModel: () => {},
        refetch: () => Promise.resolve({ data: null }),
        resetCursors: () => {}
      };
    }
    
    console.log('[useEnhancedDataGrid] Initiating GraphQL fetch');
    try {
      return useGraphQLData<T>({
        pageSize: paginationState.pageSize,
        initialPage: paginationState.page,
        query,
        variables,
        initialFilterModel: internalFilterModel.items.length > 0 ? 
          internalFilterModel.items.reduce((acc, item) => {
            if (item.field && item.value !== undefined) {
              acc[item.field] = {
                value: item.value,
                operator: item.operator || 'contains'
              };
            }
            return acc;
          }, {} as Record<string, any>) : 
          {},
        initialSortModel: internalSortModel.length > 0 ? 
          internalSortModel.map(item => ({
            field: item.field,
            sort: item.sort
          })) : 
          [],
      });
    } catch (error) {
      console.error('[useEnhancedDataGrid] Error setting up GraphQL data:', error);
      // Return empty/default state on error
      return {
        rows: [],
        totalRows: 0,
        loading: false,
        error,
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false, 
          startCursor: null,
          endCursor: null
        },
        setPage: () => {},
        setSortModel: () => {},
        setFilterModel: () => {},
        refetch: () => Promise.resolve({ data: null }),
        resetCursors: () => {}
      };
    }
  }, [
    shouldFetchData, 
    paginationState.pageSize, 
    paginationState.page, 
    query, 
    variables, 
    internalFilterModel, 
    internalSortModel
  ]);
```
// Process columns to add custom menu options
  const processedColumns = useMemo(() => {
    return columns.map((column: EnhancedColumnConfig) => {
      // Base column configuration
      const baseColumn = {
        ...column,
        // Existing transformations
      };
      
      // Add custom menu options if provided
      if (column.menuOptions) {
        baseColumn.columnMenuItems = (colDef: any) => {
          const items = [];
          
          // Add standard items if enabled (default to showing them)
          if (column.menuOptions?.showSortAsc !== false) items.push('columnMenuSortAsc');
          if (column.menuOptions?.showSortDesc !== false) items.push('columnMenuSortDesc');
          if (column.menuOptions?.showFilter !== false) items.push('columnMenuFilterItem');
          if (column.menuOptions?.showColumnSelector !== false) items.push('columnMenuColumnsItem');
          
          // Add custom items
          column.menuOptions?.customItems?.forEach(item => {
            items.push({
              label: item.label,
              icon: item.icon,
              onClick: () => {
                try {
                  item.onClick(colDef);
                } catch (error) {
                  console.error(`[useEnhancedDataGrid] Error in custom menu item click handler:`, error);
                }
              }
            });
          });
          
          return items;
        };
      }
      
      return baseColumn;
    });
  }, [columns]);
  
  // Determine displayed rows based on configuration
  const displayRows = useMemo(() => {
    if (useGraphQLFetching) {
      if (onlyLoadWithFilters && !filtersApplied) {
        console.log('[useEnhancedDataGrid] Returning empty rows - filters not applied');
        return [];
      }
      return graphQLResult.rows || [];
    }
    return rows || [];
  }, [useGraphQLFetching, onlyLoadWithFilters, filtersApplied, graphQLResult.rows, rows]);
  
  // Enhanced filter handler that tracks filter application
  const handleFilterModelChange = useCallback((newModel: GridFilterModel) => {
    console.log('[useEnhancedDataGrid] Filter model changed:', newModel);
    
    // Update internal state
    setInternalFilterModel(newModel);
    
    // Track if filters have been applied
    setFiltersApplied(newModel.items && newModel.items.length > 0);
    
    // If using GraphQL with server-side filtering
    if (useGraphQLFetching && shouldFetchData) {
      try {
        // Pass filter to GraphQL hook
        const filterObj: Record<string, any> = {};
        newModel.items.forEach(item => {
          if (item.field && item.value !== undefined) {
            filterObj[item.field] = {
              value: item.value,
              operator: item.operator || 'contains'
            };
          }
        });
        
        graphQLResult.setFilterModel?.(filterObj);
      } catch (error) {
        console.error('[useEnhancedDataGrid] Error applying filter:', error);
      }
    }
    
    // Call external handler if provided
    if (externalOnFilterModelChange) {
      externalOnFilterModelChange(newModel);
    }
  }, [
    useGraphQLFetching, 
    shouldFetchData, 
    graphQLResult.setFilterModel, 
    externalOnFilterModelChange
  ]);
  
  // Enhanced sort handler
  const handleSortModelChange = useCallback((newModel: GridSortModel) => {
    console.log('[useEnhancedDataGrid] Sort model changed:', newModel);
    
    // Update internal state
    setInternalSortModel(newModel);
    
    // If using GraphQL with server-side sorting
    if (useGraphQLFetching && shouldFetchData) {
      try {
        // Pass sort to GraphQL hook
        const sortItems = newModel.map(item => ({
          field: item.field,
          sort: item.sort
        }));
        
        graphQLResult.setSortModel?.(sortItems);
      } catch (error) {
        console.error('[useEnhancedDataGrid] Error applying sort:', error);
      }
    }
    
    // Call external handler if provided
    if (externalOnSortModelChange) {
      externalOnSortModelChange(newModel);
    }
  }, [
    useGraphQLFetching, 
    shouldFetchData, 
    graphQLResult.setSortModel, 
    externalOnSortModelChange
  ]);
  
  // Enhanced pagination handler
  const handlePaginationModelChange = useCallback((newModel: any) => {
    console.log('[useEnhancedDataGrid] Pagination model changed:', newModel);
    
    // Update internal state
    paginationState.setPage(newModel.page);
    paginationState.setPageSize(newModel.pageSize);
    
    // If using GraphQL with server-side pagination
    if (useGraphQLFetching && shouldFetchData) {
      try {
        // Pass page to GraphQL hook
        graphQLResult.setPage?.(newModel.page);
      } catch (error) {
        console.error('[useEnhancedDataGrid] Error applying pagination:', error);
      }
    }
  }, [
    useGraphQLFetching, 
    shouldFetchData, 
    graphQLResult.setPage, 
    paginationState
  ]);
  
  // Calculate total rows
  const totalRows = useMemo(() => {
    if (useGraphQLFetching) {
      return graphQLResult.totalRows || 0;
    }
    return rows?.length || 0;
  }, [useGraphQLFetching, graphQLResult.totalRows, rows?.length]);
  
  // Combine loading states
  const loading = useMemo(() => {
    return externalLoading || graphQLResult.loading;
  }, [externalLoading, graphQLResult.loading]);
  
  // Return everything the component needs
  return {
    // Grid configuration
    columns: processedColumns,
    rows: displayRows,
    totalRows,
    loading,
    error: graphQLResult.error,
    
    // State tracking
    filtersApplied,
    
    // Event handlers
    handleFilterModelChange,
    handleSortModelChange,
    handlePaginationModelChange,
    
    // Hooks state
    selectionState,
    paginationState,
    
    // GraphQL utilities
    refetch: graphQLResult.refetch,
    resetCursors: graphQLResult.resetCursors,
    pageInfo: graphQLResult.pageInfo,
    
    // Component flags
    isEmpty: displayRows.length === 0,
    isLoadingWithoutFilters: onlyLoadWithFilters && !filtersApplied
  };
}
```
### 2. Create the New UI Components

#### a. EmptyStateOverlay Component

```typescript
// components/EmptyStateOverlay.tsx
import React from 'react';
import { Typography, Button, Box } from '@mui/material';
import FilterAltIcon from '@mui/icons-material/FilterAlt';

interface EmptyStateOverlayProps {
  onFilterClick?: () => void;
}

export const EmptyStateOverlay: React.FC<EmptyStateOverlayProps> = ({ 
  onFilterClick 
}) => {
  return (
    <Box 
      className="flex flex-col items-center justify-center h-full p-8"
      sx={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 4
      }}
    >
      <FilterAltIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
      <Typography variant="h6">No Results to Display</Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2, textAlign: 'center' }}>
        Apply filters to load data for this grid
      </Typography>
      {onFilterClick && (
        <Button 
          variant="outlined" 
          startIcon={<FilterAltIcon />} 
          onClick={onFilterClick}
          size="small"
        >
          Open Filters
        </Button>
      )}
    </Box>
  );
};
```

#### b. Toolbar Components

```typescript
// components/toolbar/ViewModeToolbar.tsx
import React from 'react';
import { 
  GridToolbarContainer, 
  GridToolbarFilterButton,
  GridToolbarColumnsButton,
  GridToolbarExportButton
} from '@mui/x-data-grid';
import { Button, Chip } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import { useGridMode } from '../../context/GridModeContext';

export const ViewModeToolbar = React.forwardRef<HTMLDivElement, any>((props, ref) => {
  const { 
    addRow, 
    selectionModel, 
    clearSelection, 
    canAddRows 
  } = useGridMode();
  
  return (
    <GridToolbarContainer ref={ref}>
      <GridToolbarFilterButton />
      <GridToolbarColumnsButton />
      <GridToolbarExportButton />
      
      {canAddRows && (
        <Button 
          startIcon={<AddIcon />} 
          onClick={addRow}
          size="small"
        >
          Add
        </Button>
      )}
      
      {selectionModel.length > 0 && (
        <Chip 
          label={`${selectionModel.length} selected`}
          onDelete={clearSelection}
          size="small"
          sx={{ ml: 2 }}
        />
      )}
      
      {/* Custom actions */}
      {props.children}
    </GridToolbarContainer>
  );
});
```

```typescript
// components/toolbar/EditModeToolbar.tsx
import React from 'react';
import { GridToolbarContainer } from '@mui/x-data-grid';
import { Button, Chip } from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import CloseIcon from '@mui/icons-material/Close';
import { useGridMode } from '../../context/GridModeContext';

export const EditModeToolbar = React.forwardRef<HTMLDivElement, any>((props, ref) => {
  const { 
    saveChanges, 
    cancelChanges, 
    hasValidationErrors,
    isAddingRow,
    editingRowCount
  } = useGridMode();
  
  const actionLabel = isAddingRow ? 'Add' : 'Save';
  
  return (
    <GridToolbarContainer ref={ref}>
      <Button 
        startIcon={<SaveIcon />} 
        onClick={saveChanges}
        disabled={hasValidationErrors}
        color="primary"
        size="small"
      >
        {actionLabel}
      </Button>
      
      <Button 
        startIcon={<CloseIcon />} 
        onClick={cancelChanges}
        size="small"
      >
        Cancel
      </Button>
      
      {/* Status indicators */}
      {isAddingRow ? (
        <Chip 
          label="Adding new record" 
          color="success" 
          size="small" 
          sx={{ ml: 2 }}
        />
      ) : editingRowCount > 0 && (
        <Chip 
          label={`Editing ${editingRowCount} record(s)`} 
          color="primary" 
          size="small" 
          sx={{ ml: 2 }}
        />
      )}
      
      {hasValidationErrors && (
        <Chip 
          label="Fix validation errors" 
          color="error" 
          size="small"
          sx={{ ml: 1 }}
        />
      )}
      
      {/* Pass through children for extensibility */}
      {props.children}
    </GridToolbarContainer>
  );
});
```
```typescript
// components/toolbar/DynamicToolbar.tsx
import React, { useCallback } from 'react';
import { ViewModeToolbar } from './ViewModeToolbar';
import { EditModeToolbar } from './EditModeToolbar';
import { useGridMode } from '../../context/GridModeContext';
import { GridToolbarProps } from '@mui/x-data-grid';

export interface DynamicToolbarProps extends GridToolbarProps {
  customActions?: React.ReactNode;
  onFilterClick?: () => void;
}

export const DynamicToolbar = React.forwardRef<HTMLDivElement, DynamicToolbarProps>((props, ref) => {
  const { mode } = useGridMode();
  const { customActions, ...otherProps } = props;
  
  // Determine which toolbar to render based on current mode
  return mode === 'edit' || mode === 'add' 
    ? <EditModeToolbar ref={ref} {...otherProps}>{customActions}</EditModeToolbar> 
    : <ViewModeToolbar ref={ref} {...otherProps}>{customActions}</ViewModeToolbar>;
});
```

### 3. Update Type Definitions

```typescript
// types/columnConfig.ts
import { GridColDef } from '@mui/x-data-grid';

// Add menu options to column config
export interface EnhancedColumnConfig<T = any> extends Omit<GridColDef, 'renderCell' | 'renderEditCell'> {
  // Existing properties from EnhancedDataGridGraphQL.tsx
  fieldConfig: {
    type: 'string' | 'number' | 'date' | 'boolean' | 'select';
    options?: Array<{ value: any; label: string }>;
    renderViewMode?: (_value: T | null, _row: any) => React.ReactNode;
    renderEditMode?: (_props: any) => React.ReactNode;
    validation?: any;
    parse?: (_value: any) => T | null;
    format?: (_value: T | null) => string;
  };
  
  // Legacy field type (for backward compatibility)
  fieldType?: any;
  
  // Legacy validation (for backward compatibility)
  required?: boolean;
  validationRules?: any[];
  validator?: any;
  
  // New property for column menu configuration
  menuOptions?: {
    // Which menu items to show (defaults to true if not specified)
    showSortAsc?: boolean;
    showSortDesc?: boolean;
    showFilter?: boolean;
    showColumnSelector?: boolean;
    // Custom menu items
    customItems?: Array<{
      label: string;
      icon?: React.ReactNode;
      onClick: (colDef: GridColDef) => void;
    }>;
  };
}
```
### 4. Update Main Component to Use New Features

```typescript
// EnhancedDataGridGraphQL.tsx (modified)
import React, { useCallback } from 'react';
import { DataGrid, GridFilterModel } from '@mui/x-data-grid';
import { useEnhancedDataGrid } from './hooks/useEnhancedDataGrid';
import { GridFormProvider } from './context/GridFormContext';
import { GridModeProvider } from './context/GridModeContext';
import { DynamicToolbar } from './components/toolbar/DynamicToolbar';
import { EmptyStateOverlay } from './components/EmptyStateOverlay';

// Keep existing interfaces and add new props
export interface EnhancedDataGridGraphQLProps<T = any> {
  // Existing props...
  
  // New props
  onlyLoadWithFilters?: boolean;
  customToolbarActions?: React.ReactNode;
}

export function EnhancedDataGridGraphQL<T extends { id: GridRowId }>({
  // Add new props
  onlyLoadWithFilters = false,
  customToolbarActions,
  // Existing props
  ...props
}) {
  console.log('[EnhancedDataGridGraphQL] Rendering with props:', {
    onlyLoadWithFilters,
    // Log other key props
  });
  
  // Use the master hook for state management and logic
  const {
    columns,
    rows,
    totalRows,
    loading,
    error,
    filtersApplied,
    handleFilterModelChange,
    handleSortModelChange,
    handlePaginationModelChange,
    selectionState,
    paginationState,
    isEmpty,
    isLoadingWithoutFilters
  } = useEnhancedDataGrid({
    ...props,
    onlyLoadWithFilters
  });
  
  // Filter panel reference for empty state
  const filterPanelRef = React.useRef<any>(null);
  
  // Callback to open filter panel
  const handleOpenFilterPanel = useCallback(() => {
    // Find and click the filter button
    const filterButton = document.querySelector('.MuiDataGrid-toolbarFilterButton');
    if (filterButton && filterButton instanceof HTMLElement) {
      filterButton.click();
    }
  }, []);
  
  return (
    <GridFormProvider
      columns={columns}
      initialRows={rows}
      onSave={props.onSave}
      validateRow={props.validateRow}
      isCompact={props.rowHeight !== undefined && props.rowHeight <= 30}
    >
      <GridModeProvider
        totalRows={totalRows}
        initialMode="none"
        selectionModel={selectionState.selectionModel}
        onSelectionModelChange={selectionState.onSelectionModelChange}
        saveChanges={() => {}}  // Implement this
        cancelChanges={() => {}} // Implement this
        addRow={() => {}} // Implement this
        hasValidationErrors={false} // Implement this
        canEditRows={props.canEditRows}
        canAddRows={props.canAddRows}
        canSelectRows={props.canSelectRows}
        canDeleteRows={props.canDeleteRows}
        onDelete={props.onDelete}
      >
        <DataGrid
          columns={columns}
          rows={rows}
          loading={loading}
          
          // Pagination
          paginationModel={paginationState.paginationModel}
          onPaginationModelChange={handlePaginationModelChange}
          paginationMode={props.paginationMode || 'server'}
          rowCount={totalRows}
          pageSizeOptions={props.rowsPerPageOptions || [10, 25, 50, 100]}
          
          // Selection
          checkboxSelection={props.checkboxSelection}
          rowSelectionModel={selectionState.selectionModel}
          onRowSelectionModelChange={selectionState.onSelectionModelChange}
          
          // Sorting and filtering
          sortingMode={props.sortingMode || 'server'}
          onSortModelChange={handleSortModelChange}
          filterMode={props.filterMode || 'server'}
          onFilterModelChange={handleFilterModelChange}
          
          // Custom components
          slots={{
            toolbar: DynamicToolbar,
            noRowsOverlay: isLoadingWithoutFilters ? EmptyStateOverlay : undefined,
            // Other slots
          }}
          slotProps={{
            toolbar: {
              customActions: customToolbarActions,
              onFilterClick: handleOpenFilterPanel
            },
            noRowsOverlay: {
              onFilterClick: handleOpenFilterPanel
            }
          }}
          
          // Other props from the input
          density={props.density || 'standard'}
          editMode="cell"
          disableRowSelectionOnClick={props.disableSelectionOnClick}
          
          // Error handling
          {...(error ? { error: true } : {})}
        />
      </GridModeProvider>
    </GridFormProvider>
  );
}
```

### 5. Update Hook Exports

```typescript
// hooks/index.ts (updated)
export * from './useGridNavigation';
export * from './useGridValidation';
export * from './useServerSideData';
export * from './useRelayGraphQLData';
export * from './useSelectionModel';
export * from './usePagination';
export * from './useEnhancedDataGrid'; // Add the new hook export
```
## Usage Example

Here's how the enhanced DataGrid would be used in a component:

```typescript
// MTMAdjustmentsPage.tsx (example usage)
import React, { useState } from 'react';
import { GridRowId } from '@mui/x-data-grid';
import { Paper, Button } from '@mui/material';
import BarChartIcon from '@mui/icons-material/BarChart';
import { gql } from '@apollo/client';
import { EnhancedDataGridGraphQL } from '../components/DataGrid';
import { ValidationHelpers } from '../components/DataGrid/context/GridFormContext';

// Existing code...

// Custom toolbar actions
const CustomActions = () => {
  const handleAnalyticsClick = () => {
    console.log('Show analytics for current data');
    // Analytics logic
  };
  
  return (
    <Button
      startIcon={<BarChartIcon />}
      onClick={handleAnalyticsClick}
      size="small"
    >
      Analytics
    </Button>
  );
};

export default function MTMAdjustmentsPage() {
  // Existing state...
  
  return (
    <div className="h-full w-full flex flex-col p-4">
      <h1 className="text-2xl font-bold mb-4">MTM Adjustments</h1>
      
      {/* Data Grid with new features */}
      <Paper elevation={0} className="flex-grow w-full overflow-auto">
        <EnhancedDataGridGraphQL
          columns={mtmAdjustmentColumns}
          rows={sampleMTMAdjustments} // Used as fallback
          
          // Enable conditional loading
          onlyLoadWithFilters={true}
          
          // Pass custom toolbar actions
          customToolbarActions={<CustomActions />}
          
          // Existing props
          onSave={handleSave}
          validateRow={validateMTMAdjustmentRow}
          useGraphQL={useGraphQLFetching}
          query={GET_MTM_ADJUSTMENTS}
          variables={variables}
          checkboxSelection={true}
          selectionModel={selectionModel}
          onSelectionModelChange={handleSelectionChange}
          canEditRows={true}
          canAddRows={true}
          canSelectRows={true}
          density="standard"
          disableSelectionOnClick={true}
          pageSize={25}
          rowsPerPageOptions={[10, 25, 50, 100]}
        />
      </Paper>
    </div>
  );
}
```

## Additional Files to Check

For a complete implementation, we should also review:

1. **context/GridModeContext.tsx** - Ensure it exposes all needed state for the toolbar
2. **context/GridFormContext.tsx** - Check it supports the validation workflow
3. **hooks/useRelayGraphQLData.ts** - Verify it can handle the conditional loading approach
4. **hooks/useSelectionModel.ts** - Confirm it properly manages selection state
5. **hooks/usePagination.ts** - Ensure pagination works with the new approach

## Error Handling and Logging Strategy

1. **Component-Level Error Boundaries**: Add error boundaries around key components to prevent full UI crashes
2. **Consistent Logging Pattern**: Use structured logging at each level:
   - `[ComponentName] Message: details`
   - Include relevant state in logs
   - Log at important lifecycle points (init, update, error)
3. **Graceful Error Recovery**: Provide fallbacks for common failure modes
4. **User-Friendly Error States**: Show helpful messages rather than breaking the UI

## Implementation Sequence

To implement this plan effectively, we should follow this sequence:

1. Create the type definitions first (`columnConfig.ts`)
2. Implement the master hook (`useEnhancedDataGrid.ts`)
3. Create the UI components (EmptyStateOverlay and toolbar components)
4. Update the main component to use the new features
5. Update the hook exports
6. Test with an example page

## Summary

This plan provides a clear, logical enhancement to the EnhancedDataGrid while maintaining the core structure:

1. **The master hook (`useEnhancedDataGrid`)** unifies all functionality and provides a clean interface
2. **New UI components** are organized in a logical folder structure
3. **Type definitions** are extended rather than replaced
4. **The main component** is updated to use the new features while maintaining its API
5. **Proper error handling** ensures stability

The approach minimizes changes to file structure while improving clarity and functionality. By isolating most changes to new files, we reduce the risk of breaking existing usage patterns.

Key benefits of this implementation:

- **Conditional Loading**: Allows grids to only load data when filters are applied
- **Unified Interface**: Provides a single hook that manages all grid state
- **Improved Toolbars**: Context-aware toolbars that change based on grid mode
- **Enhanced Column Menus**: Customizable column menu options
- **Better Error Handling**: Comprehensive error handling and logging

This implementation follows the principle of progressive enhancement, allowing existing code to continue working while providing new capabilities for future development.


====== docs/grid-reducer-architecture.md ======
Last Modified: 4/23/2025, 04:55 | Size: 4.8 KB | Lines: 136

# Grid Reducer Architecture

This document outlines the new reducer-based architecture for the DataGrid component, which addresses several performance and state management issues in the current implementation.

## Overview

The new architecture uses a reducer pattern to manage state in a more predictable and efficient way. This approach offers several advantages:

1. **Centralized State Management**: All grid-related state is managed in a single location, making it easier to track changes and debug issues.
2. **Predictable State Updates**: State changes follow a clear action → reducer → state flow, reducing race conditions and unexpected behavior.
3. **Improved Performance**: By batching updates and preventing unnecessary re-renders, the grid performs better, especially with large datasets.
4. **Better Debugging**: Actions provide a clear history of what happened, making it easier to trace issues.

## Key Components

### 1. GridReducer

The `gridReducer.ts` file defines the state shape, actions, and reducer function for the grid. It handles all state transitions in a pure, predictable way.

```typescript
// Example of dispatching an action
dispatch({ type: 'ADD_ROW', payload: { row, columns } });
```

### 2. GridContextProvider

The `GridContextProvider.tsx` component wraps the reducer with React's context API, making the state and dispatch function available throughout the component tree. It also provides helper functions that abstract away the action dispatching details.

```typescript
// Using the context in a component
const { addRow, saveChanges, state } = useGridContext();
```

## Migration Guide

To migrate from the current context-based implementation to the new reducer architecture, follow these steps:

### Step 1: Replace Context Providers

Replace the existing context providers with the new `GridContextProvider`:

```tsx
// Before
<GridFormProvider columns={columns} initialRows={rows} onSave={handleSave}>
  <GridModeProvider>
    {children}
  </GridModeProvider>
</GridFormProvider>

// After
<GridContextProvider columns={columns} initialRows={rows} onSave={handleSave}>
  {children}
</GridContextProvider>
```

### Step 2: Update Context Consumers

Replace calls to `useGridForm` and `useGridMode` with `useGridContext`:

```tsx
// Before
const { addRow, saveChanges } = useGridForm();
const { mode, setMode } = useGridMode();

// After
const { addRow, saveChanges, state, setMode } = useGridContext();
const mode = state.mode;
```

### Step 3: Update DataGrid Component

Update the DataGrid component to use the new state management:

```tsx
// Before
<DataGrid
  rows={rows}
  checkboxSelection={checkboxSelection}
  rowSelectionModel={selectionModel}
  onRowSelectionModelChange={handleSelectionModelChange}
  // ...
/>

// After
<DataGrid
  rows={state.rows}
  checkboxSelection={checkboxSelection}
  rowSelectionModel={state.selectionModel}
  onRowSelectionModelChange={(newModel) => setSelectionModel(newModel)}
  // ...
/>
```

## Benefits of the New Architecture

### 1. Fixed Add Row Functionality

The new architecture fixes issues with the add row functionality by:
- Using a timestamp-based ID generation for better uniqueness
- Batching state updates to prevent race conditions
- Properly tracking new rows in the state

### 2. Fixed Selection Model

The selection model improvements include:
- Preventing unnecessary re-renders by checking if the selection has actually changed
- Using memoization to optimize performance
- Batching updates to prevent UI flickering

### 3. Fixed Filter UI Issues

The filter UI improvements include:
- Tracking when the filter panel is open to prevent unnecessary updates
- Delaying filter application to prevent UI flickering
- Using a more robust approach to filter model changes

## Performance Optimizations

The new architecture includes several performance optimizations:

1. **Memoized Selectors**: Computed properties are memoized to prevent unnecessary recalculations.
2. **Batched Updates**: State updates are batched to reduce re-renders.
3. **Efficient State Structure**: The state structure is designed to make common operations efficient.

## Future Improvements

Future improvements to the architecture could include:

1. **Middleware Support**: Add middleware for logging, analytics, or other cross-cutting concerns.
2. **Undo/Redo Support**: Implement undo/redo functionality by tracking action history.
3. **Persistence**: Add support for persisting grid state to localStorage or a backend.
4. **Virtual Scrolling Optimization**: Further optimize virtual scrolling for very large datasets.

## Conclusion

The new reducer-based architecture provides a solid foundation for the DataGrid component, addressing current issues and providing a path for future improvements. By centralizing state management and making state transitions more predictable, it improves both developer experience and end-user performance.


====== docs/add-functionality-implementation-plan.md ======
Last Modified: 4/17/2025, 14:25 | Size: 4.6 KB | Lines: 159

# Add Functionality Implementation Plan

## Issues Identified

After analyzing the codebase, we've identified several issues with the "Add" functionality in the MTM History page:

1. **New Row Position**: In the `addRow` function in GridFormContext (line 700), new rows are being added to the end of the grid, not at the top:
   ```javascript
   // Add the row to the grid
   setRows(prev => [...prev, newRow]);
   ```

2. **Refetching After Save**: In the mtm-history.tsx file, the refetch function is commented out in both the save and delete handlers:
   ```javascript
   // Refetch data after saving (optional, depends on mutation response/cache updates)
   // refetch();
   ```

3. **Access to Refetch Function**: There's no clear way for the mtm-history.tsx component to access the refetch function from the EnhancedDataGridGraphQL component.

## Implementation Plan

### 1. Fix New Row Position

Modify the `addRow` function in GridFormContext to add new rows at the top of the grid:

```javascript
// Change from
setRows(prev => [...prev, newRow]);

// To
setRows(prev => [newRow, ...prev]);
```

**File**: `components/DataGrid/context/GridFormContext.tsx` (line 700)

### 2. Implement Access to Refetch Function

We need to implement the `onGridFunctionsInit` callback in the EnhancedDataGridGraphQL component to provide access to the refetch function.

1. In the EnhancedDataGridGraphQL component, extract the refetch function from graphQLResult:
   ```javascript
   const {
     rows: graphQLRows,
     totalRows: graphQLTotalRows,
     loading: graphQLLoading,
     setPage,
     setSortModel,
     setFilterModel,
     refetch, // Extract refetch
     pageInfo, // Extract pageInfo
     resetCursors, // Extract resetCursors
   } = useGraphQLFetching
     ? graphQLResult
     : { /* ... */ };
   ```

2. Add an effect to call the onGridFunctionsInit callback when the component mounts:
   ```javascript
   useEffect(() => {
     if (props.onGridFunctionsInit && useGraphQLFetching) {
       props.onGridFunctionsInit(
         refetch,
         resetCursors,
         pageInfo
       );
     }
   }, [props.onGridFunctionsInit, refetch, resetCursors, pageInfo, useGraphQLFetching]);
   ```

**File**: `components/DataGrid/EnhancedDataGridGraphQL.tsx`

### 3. Use the Refetch Function in MTM History Page

1. Add a state variable to store the refetch function:
   ```javascript
   const [refetchData, setRefetchData] = useState<() => Promise<any>>(() => Promise.resolve({ data: null }));
   ```

2. Implement the onGridFunctionsInit callback:
   ```javascript
   const handleGridFunctionsInit = (
     refetch: () => Promise<any>,
     resetCursors: () => void,
     pageInfo: any
   ) => {
     setRefetchData(() => refetch);
   };
   ```

3. Pass the callback to the EnhancedDataGridGraphQL component:
   ```jsx
   <EnhancedDataGridGraphQL
     // ... other props
     onGridFunctionsInit={handleGridFunctionsInit}
   />
   ```

4. Uncomment and update the refetch calls in the save and delete handlers:
   ```javascript
   // In handleSave
   try {
     // ... existing code
     
     // Refetch data after saving
     refetchData();
     
     alert('Changes saved (simulated). Check console.');
   } catch (error) {
     // ... error handling
   }
   
   // In handleDelete
   try {
     // ... existing code
     
     // Refetch data after deleting
     refetchData();
     
     alert(`${ids.length} row(s) deleted (simulated). Check console.`);
   } catch (error) {
     // ... error handling
   }
   ```

**File**: `pages/mtm-history.tsx`

### 4. Verify Validation Consistency

Ensure that validation rules are applied consistently in both edit and add modes:

1. Check that the same validation rules are applied in both modes
2. Verify that validation errors are displayed correctly
3. Confirm that the Save button is disabled when there are validation errors

## Testing Plan

After implementing these changes, we should test:

1. **Add Functionality**:
   - Verify that new rows are added at the top of the grid
   - Ensure all fields are editable in the new row
   - Check that validation works correctly

2. **Edit Functionality**:
   - Verify that existing rows can be edited
   - Ensure validation works correctly

3. **Save Functionality**:
   - Verify that changes are saved correctly
   - Ensure the grid is refreshed after saving

4. **Delete Functionality**:
   - Verify that rows can be deleted
   - Ensure the grid is refreshed after deleting

## Conclusion

By implementing these changes, we will ensure that the "Add" functionality in the MTM History page works correctly, with new rows added at the top of the grid and proper validation and error handling.


====== docs/pagination-fix-summary.md ======
Last Modified: 4/15/2025, 17:40 | Size: 3.3 KB | Lines: 100

# Pagination Fix Summary

This document summarizes the changes made to fix the pagination issues in the MTM History grid.

## Issues Fixed

1. **Cursor Management**: Fixed issues with cursor storage and retrieval in the `useRelayGraphQLData` hook.
2. **Data Refresh**: Ensured that data is properly refreshed when navigating between pages.
3. **Pagination Direction**: Improved handling of pagination direction for cursor-based pagination.
4. **Stable Data**: Implemented stable data generation for consistent testing.

## Key Changes

### 1. In `useRelayGraphQLData.ts`:

- Changed the `fetchPolicy` to `"network-only"` to ensure fresh data is always fetched:
  ```typescript
  const { data, loading, error, refetch } = useQuery(query, {
    variables,
    notifyOnNetworkStatusChange: true,
    fetchPolicy: "network-only", // Always fetch from network
    skip: !query || Object.keys(variables).length === 0,
  });
  ```

- Removed throttling in the refetch effect to ensure data is always refreshed:
  ```typescript
  useEffect(() => {
    if (!query || Object.keys(variables).length === 0) return;
    
    console.log('Refetching with variables:', variables);
    
    // Always refetch when variables change
    refetch(variables).then(() => {
      console.log('Refetch complete');
    }).catch(err => {
      console.error('Refetch error:', err);
    });
  }, [query, refetch, variables]);
  ```

### 2. In `EnhancedDataGridGraphQL.tsx`:

- Added a forced refetch after page changes with a slight delay to ensure state updates have propagated:
  ```typescript
  // Force a refetch with a slight delay
  setTimeout(() => {
    console.log("Forcing refetch after page change to page", model.page);
    // This will trigger the useEffect in the hook that watches variables
    const currentVars = { ...variables };
  }, 50);
  ```

### 3. Stable Data Generation:

- Created utilities to generate stable data with a fixed seed:
  - `utils/stableDataGenerator.js`: Functions to generate stable data
  - `scripts/generate-test-data.js`: Script to generate test data

- Updated the MTM History resolver to use stable data:
  ```javascript
  // Try to load from file first
  const loadedData = loadDataFromFile(STABLE_DATA_FILE);
  
  if (loadedData && loadedData.length > 0) {
    cachedMTMHistory = loadedData;
  } else {
    // Generate new data with fixed seed
    const newData = generateStableMTMHistoryData(500, 12345);
    cachedMTMHistory = newData;
    
    // Save to file for future use
    saveDataToFile(newData, STABLE_DATA_FILE);
  }
  ```

### 4. Pagination Testing:

- Created a pagination test page (`pages/pagination-test.tsx`) to verify pagination functionality
- Implemented utilities to verify pagination results against expected data

## How to Test

1. Generate stable test data:
   ```
   node scripts/generate-test-data.js
   ```

2. Run the application:
   ```
   npm run dev
   ```

3. Navigate to `/pagination-test` to test pagination
   - Click "Next" multiple times to verify pagination works correctly
   - Use the "Verify Current Page" button to check against expected data

## Conclusion

These changes ensure that the Relay-style cursor-based pagination works correctly, with proper data refresh when navigating between pages. The stable data generation and testing approach provide a reliable way to verify the pagination functionality.


====== docs/mtm-history-pagination-fix.md ======
Last Modified: 4/15/2025, 17:22 | Size: 4.6 KB | Lines: 134

# MTM History Pagination Fix

This document outlines the fixes implemented for the MTM History pagination issues and the approach for testing with stable data.

## Issues Fixed

1. **Cursor Management Issue**: The way cursors were being stored and retrieved in the `useRelayGraphQLData` hook was problematic. When clicking "Next" multiple times, the cursor for subsequent pages wasn't being properly managed.

2. **Pagination Variables Construction**: The logic for constructing pagination variables needed improvement to handle multiple "Next" clicks correctly.

3. **Random Data Generation**: The mock data in the resolver was generated randomly each time, making testing inconsistent.

## Implementation Details

### 1. Cursor Management Fix

The `useRelayGraphQLData` hook has been updated to:

- Add better tracking of cursor state with improved logging
- Fix the logic for constructing pagination variables
- Ensure cursors are properly stored for each page
- Add a `lastFetchedPage` state to track which page was last fetched

```typescript
// Key changes in useRelayGraphQLData.ts
const [lastFetchedPage, setLastFetchedPage] = useState<number | null>(null);

// Improved pagination variables construction
const paginationVars = useMemo(() => {
  // For forward pagination, use the cursor from the previous page
  if (paginationDirection === "forward") {
    if (page === 0) {
      return { first: effectivePageSize, after: null };
    }
    
    const cursor = cursors[page - 1];
    return { first: effectivePageSize, after: cursor || null };
  } else {
    // For backward pagination
    const cursor = cursors[page + 1];
    return { last: effectivePageSize, before: cursor || null };
  }
}, [paginationDirection, pageSize, page, cursors]);
```

### 2. Pagination Direction Handling

The `EnhancedDataGridGraphQL` component has been updated to properly handle pagination direction:

```typescript
onPaginationModelChange={(model) => {
  if (useGraphQLFetching) {
    // For Relay cursor pagination, we need to handle "Next" and "Previous" differently
    if (paginationStyle === 'cursor') {
      // If we're going to the next page, set pagination direction to forward
      if (model.page > 0) {
        setPaginationDirection("forward");
      }
    }
    
    // Set the page
    setPage(model.page);
  }
}}
```

### 3. Stable Data Generation

A new utility has been created to generate stable data with a fixed seed:

- `utils/stableDataGenerator.ts`: Provides functions to generate stable data with a fixed seed
- `scripts/generate-stable-data.ts`: Script to generate and save stable data to a file
- Updated resolver to use the stable data from file

```typescript
// In graphql/resolvers/mtm-history.ts
function getMTMHistoryData(): MTMHistoryItem[] {
  if (!cachedMTMHistory) {
    // Try to load from file first
    const loadedData = loadDataFromFile<MTMHistoryItem[]>(STABLE_DATA_FILE);
    
    if (loadedData && loadedData.length > 0) {
      cachedMTMHistory = loadedData;
    } else {
      // Generate new data with fixed seed
      cachedMTMHistory = generateStableMTMHistoryData(500, 12345);
      
      // Save to file for future use
      saveDataToFile(cachedMTMHistory, STABLE_DATA_FILE);
    }
  }
  
  return cachedMTMHistory;
}
```

## Testing Approach

A comprehensive testing approach has been implemented:

1. **Stable Data Generation**: Data is generated with a fixed seed and saved to a file, ensuring consistent test data.

2. **Pagination Test Data**: Expected pagination results are pre-calculated and saved to a file, providing a reference for verification.

3. **Pagination Test Page**: A dedicated test page (`pages/pagination-test.tsx`) has been created to:
   - Display the paginated data
   - Allow verification against expected data
   - Show detailed error messages if verification fails

4. **Verification Utility**: The `utils/paginationTestHelper.ts` utility provides functions to:
   - Generate expected pagination test data
   - Verify actual pagination results against expected data

## How to Test

1. Generate stable data:
   ```
   npx ts-node scripts/generate-stable-data.ts
   ```

2. Generate pagination test data:
   ```
   npx ts-node scripts/generate-pagination-test-data.ts
   ```

3. Run the application and navigate to `/pagination-test`

4. Test pagination by:
   - Clicking "Next" multiple times
   - Verifying each page against expected data using the "Verify Current Page" button

## Conclusion

These fixes ensure that the Relay-style cursor-based pagination works correctly, even when clicking "Next" multiple times. The stable data generation and testing approach provide a reliable way to verify the pagination functionality.


====== docs/mtm-history-pagination-fix-plan.md ======
Last Modified: 4/15/2025, 15:16 | Size: 3.5 KB | Lines: 94

# MTM History Pagination Fix Plan

## Issue

We're encountering a "Too many re-renders" error when using GraphQL fetching with the `EnhancedDataGridGraphQL` component. The error occurs specifically when:

1. The GraphQL fetching is enabled (`useGraphQLFetching` is set to `true`)
2. The component is using Relay-style cursor-based pagination (`paginationStyle="cursor"`)

The root cause appears to be related to how the DynamoDB backend requires a key condition for queries, but our GraphQL integration isn't properly handling this requirement.

## Error Details

The specific error from DynamoDB is:

```
"Either the KeyConditions or KeyConditionExpression parameter must be specified in the request."
```

This is a common requirement for DynamoDB queries, which need a partition key (and optionally a sort key) to be specified in the query.

## Solution Approaches

### 1. Client-Side Workaround (Immediate Fix)

The simplest workaround is to use client-side data instead of GraphQL fetching. This works because the sample data is already available in the component.

```tsx
// In pages/mtm-history.tsx
const [useGraphQLFetching, setUseGraphQLFetching] = useState(false); // Start with client-side data
```

### 2. Backend Fix (Proper Solution)

The proper solution is to modify the backend to handle the DynamoDB key condition requirement:

1. **Modify the GraphQL resolver**: Update the `mtm-history.ts` resolver to handle the case when no filter is provided by using a default filter or by not enforcing the key condition requirement in development/testing environments.

2. **Add a default filter**: When using GraphQL fetching, always provide a default filter that includes the necessary key condition:

```tsx
// In pages/mtm-history.tsx
variables={{
  filter: JSON.stringify({
    commodity: "Oil" // This is just an example, adjust as needed for your DynamoDB key
  })
}}
```

3. **Fix the Apollo Server setup**: Ensure the Apollo Server is properly handling multiple requests by tracking its state:

```typescript
// In graphql/apollo-server.ts
let serverStarted = false;

export const startServer = async () => {
  if (!serverStarted) {
    await apolloServer.start();
    serverStarted = true;
  }
  return apolloServer;
};
```

### 3. Optimize the useRelayGraphQLData Hook

The `useRelayGraphQLData` hook might be causing re-renders due to how it handles variables and dependencies:

1. Simplify variable creation to avoid recreating objects on every render
2. Use separate `useEffect` hooks for pagination and filtering/sorting
3. Use stable references for variables in the `useEffect` hooks

## Implementation Plan

1. Start with the client-side workaround to get the component working
2. Implement the backend fixes to properly handle the DynamoDB key condition
3. Optimize the `useRelayGraphQLData` hook to avoid unnecessary re-renders
4. Test with GraphQL fetching enabled

## Testing

After implementing the fixes, test the following scenarios:

1. Client-side data (useGraphQLFetching = false)
2. GraphQL fetching with default filter (useGraphQLFetching = true)
3. GraphQL fetching with user-provided filter
4. Pagination, sorting, and filtering with both client-side and server-side data

## Long-term Recommendations

1. Add proper error handling in the GraphQL resolvers
2. Add validation for required parameters in the GraphQL schema
3. Consider using a more robust approach for DynamoDB integration, such as the AWS AppSync DynamoDB resolver
4. Add comprehensive logging to help diagnose similar issues in the future


====== docs/mtm-history-pagination-solution-summary.md ======
Last Modified: 4/15/2025, 12:53 | Size: 4.6 KB | Lines: 140

# MTM History Pagination Solution Summary

## System Overview

The MTM History data grid uses a GraphQL API with Relay-style cursor pagination to fetch data from a DynamoDB backend. The key components are:

1. **Frontend**: `pages/mtm-history.tsx` renders the `EnhancedDataGridGraphQL` component
2. **GraphQL API**: Defines the `mtmHistory` query that accepts pagination, filtering, and sorting parameters
3. **Backend Resolver**: Processes the query and interacts with DynamoDB
4. **DynamoDB**: Stores the MTM history data and requires key conditions for queries

## Current Issues

1. **DynamoDB Error**: `Either the KeyConditions or KeyConditionExpression parameter must be specified in the request`
   - **Root Cause**: The frontend doesn't provide filter variables that include the necessary key conditions
   - **Impact**: Initial data fetch fails with an error

2. **Pagination Issue**: Same records returned when clicking "next" in pagination
   - **Root Cause**: Improper cursor handling in the backend
   - **Impact**: Users can't navigate through the data effectively

## Schema Analysis

The GraphQL schema for the `mtmHistory` query:

```graphql
mtmHistory(
  first: Int
  after: String
  filter: String
  sort: String
): MTMHistoryConnection!
```

Key observations:
- `filter` is a String that needs to be parsed into an object
- The frontend needs to include key conditions in this filter string
- The response follows the Relay Connection specification

## Solution Strategy

### 1. Frontend Updates

Update `pages/mtm-history.tsx` to include the necessary filter variables:

```tsx
<EnhancedDataGridGraphQL
  // ... existing props
  variables={{
    first: 25,
    filter: JSON.stringify({
      // Include the required partition key for DynamoDB
      user_id: 'default-user' // Or appropriate default value
    }),
    sort: '[{"field": "accounting_mtm_history_id", "direction": "DESC"}]',
  }}
  // ... other props
/>
```

### 2. Backend Improvements

Enhance the resolver in `graphql/resolvers/mtm-history.ts` to:

1. **Validate Key Conditions**:
   - Parse the filter string
   - Check for required key condition fields
   - Return appropriate error if missing

2. **Improve Cursor Handling**:
   - Use proper cursor encoding/decoding
   - Correctly find the starting position for pagination
   - Return accurate page information

### 3. Testing Approach

1. **Unit Tests**:
   - Test filter parsing and validation
   - Test cursor encoding/decoding
   - Test pagination logic

2. **Integration Tests**:
   - Test the full flow from frontend to backend
   - Verify error handling for missing key conditions
   - Verify pagination works correctly

## Implementation Plan

### Phase 1: Frontend Fix

1. Update `pages/mtm-history.tsx` to include filter variables with key conditions
2. Test the initial data fetch to ensure it succeeds

### Phase 2: Backend Enhancement

1. Improve the resolver to better handle filters and validate key conditions
2. Enhance cursor handling for reliable pagination
3. Test pagination to ensure different records are returned for each page

### Phase 3: Documentation & Knowledge Sharing

1. Document the DynamoDB key condition requirements
2. Update API documentation to clearly indicate required filter parameters
3. Share lessons learned with the team

## Recommended Next Steps

1. Implement the frontend fix first, as it's simpler and may resolve the immediate error
2. Test with the existing backend to see if pagination works
3. If pagination issues persist, implement the backend enhancements
4. Consider adding a UI for users to specify filter criteria

## Technical Considerations

### DynamoDB Query Requirements

DynamoDB Query operations require:
- A condition on the partition key (mandatory)
- Optional conditions on the sort key
- These conditions form the `KeyConditionExpression`

### Relay Cursor Pagination

Relay cursor pagination:
- Uses opaque cursors to mark positions in the result set
- Provides `hasNextPage` and `hasPreviousPage` flags
- Allows for efficient pagination without offset/limit

### GraphQL Variable Handling

The current implementation:
- Expects `filter` and `sort` as strings that need to be parsed
- Should validate and handle these parameters consistently
- Needs to propagate key conditions to DynamoDB

## Conclusion

The primary issue is the missing key conditions in the filter variables sent from the frontend. By adding these key conditions and improving the backend's handling of filters and cursors, we can resolve both the DynamoDB error and the pagination issues.

This solution maintains the existing architecture while addressing the specific problems, providing a path to a robust and reliable data grid implementation.


====== docs/mtm-history-pagination-flow.md ======
Last Modified: 4/15/2025, 12:52 | Size: 3.8 KB | Lines: 120

# MTM History Pagination Data Flow

This document visualizes the data flow for the MTM History pagination implementation and highlights where the current issues occur.

## Current Flow (With Issues)

```mermaid
sequenceDiagram
    participant FE as Frontend (mtm-history.tsx)
    participant GQL as GraphQL Layer
    participant BE as Backend Service
    participant DB as DynamoDB

    FE->>GQL: Query mtmHistory(first: 25, sort: "...")
    Note over FE,GQL: Missing filter variables with key conditions
    GQL->>BE: mtmHistory resolver calls service
    BE->>DB: Query without KeyConditionExpression
    DB-->>BE: Error: KeyConditions must be specified
    BE-->>GQL: Error response
    GQL-->>FE: Error response

    Note over FE,DB: When pagination works but returns same records:
    FE->>GQL: Query mtmHistory(first: 25, after: "cursor", sort: "...")
    GQL->>BE: mtmHistory resolver with cursor
    BE->>DB: Query with same/incorrect ExclusiveStartKey
    DB-->>BE: Same records as first page
    BE-->>GQL: Connection with same records
    GQL-->>FE: Same records displayed again
```

## Proposed Solution Flow

```mermaid
sequenceDiagram
    participant FE as Frontend (mtm-history.tsx)
    participant GQL as GraphQL Layer
    participant BE as Backend Service
    participant DB as DynamoDB

    FE->>GQL: Query mtmHistory(first: 25, filter: {user_id: "default"}, sort: "...")
    Note over FE,GQL: Added required filter variables
    GQL->>BE: mtmHistory resolver calls service
    BE->>DB: Query with KeyConditionExpression
    DB-->>BE: First page of results
    BE-->>GQL: Connection with edges, pageInfo
    GQL-->>FE: Display first page

    FE->>GQL: Query mtmHistory(first: 25, after: "cursor", filter: {user_id: "default"}, sort: "...")
    GQL->>BE: mtmHistory resolver with cursor
    BE->>DB: Query with correct ExclusiveStartKey
    DB-->>BE: Next page of results
    BE-->>GQL: Connection with new edges, pageInfo
    GQL-->>FE: Display second page
```

## Mock Implementation Architecture

```mermaid
graph TD
    A[Frontend Request] --> B[GraphQL Resolver]
    B --> C{Validate Key Conditions}
    C -->|Missing| D[Return Error]
    C -->|Valid| E[Get Mock Data]
    E --> F[Apply Filters]
    F --> G[Apply Sorting]
    G --> H[Apply Cursor Pagination]
    H --> I[Format as Connection]
    I --> J[Return Response]

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style H fill:#ccf,stroke:#333,stroke-width:2px
```

## Data Transformation Flow

```mermaid
graph LR
    A[Raw Query Args] --> B[Parse Filter]
    A --> C[Parse Sort]
    A --> D[Extract Cursor]
    B --> E[Validate Key Conditions]
    E --> F[Filter Data]
    C --> G[Sort Data]
    F --> G
    G --> H[Find Start Position]
    D --> H
    H --> I[Slice Data]
    I --> J[Create Edges]
    I --> K[Calculate PageInfo]
    J --> L[Return Connection]
    K --> L

    style E fill:#f9f,stroke:#333,stroke-width:2px
    style H fill:#ccf,stroke:#333,stroke-width:2px
    style J fill:#cfc,stroke:#333,stroke-width:2px
```

## Key Components and Responsibilities

### Frontend (`pages/mtm-history.tsx`)
- Provide required filter variables with key conditions
- Pass the GraphQL query and variables to EnhancedDataGridGraphQL
- Handle UI interactions and display

### GraphQL Resolver (`graphql/resolvers/mtm-history.ts`)
- Parse and validate query arguments
- Enforce key condition requirements
- Apply filtering, sorting, and pagination
- Format response as a Relay Connection

### Mock Data Service
- Generate and cache mock MTM history data
- Simulate DynamoDB behavior for testing
- Implement cursor-based pagination logic

### DynamoDB Pagination Service (Real Implementation)
- Build proper KeyConditionExpression from filter
- Handle cursor-based pagination with ExclusiveStartKey
- Apply additional filtering and sorting
- Return consistent Connection structure


====== docs/relay-pagination-implementation.md ======
Last Modified: 4/14/2025, 09:28 | Size: 10.9 KB | Lines: 394

# Implementing Relay-Style Pagination in EnhancedDataGridGraphQL

This document outlines the implementation plan for adapting the `EnhancedDataGridGraphQL` component to work with Relay-style cursor-based pagination.

## Overview

The current implementation uses offset-based pagination with `page` and `pageSize` parameters, but we need to adapt it to work with a Relay-style GraphQL query that uses cursor-based pagination with `first` and `after` parameters.

## Implementation Steps

### 1. Create a New Hook for Relay-Style Pagination

Create a new hook called `useRelayGraphQLData` that handles cursor-based pagination:

```typescript
// components/DataGrid/hooks/useRelayGraphQLData.ts

import { useState, useEffect } from 'react';
import { useQuery } from '@apollo/client';
import { ServerSideResult } from '../types/serverSide';

export function useRelayGraphQLData<T>({
  pageSize,
  initialPage = 0,
  initialSortModel = [],
  initialFilterModel = {},
  query,
  variables: customVariables = {},
  nodeToRow = (node: any) => node as T,
}: {
  pageSize: number;
  initialPage?: number;
  initialSortModel?: { field: string; sort: 'asc' | 'desc' }[];
  initialFilterModel?: Record<string, any>;
  query?: any;
  variables?: Record<string, any>;
  nodeToRow?: (node: any) => T;
}): ServerSideResult<T> {
  // State for pagination
  const [page, setPage] = useState(initialPage);
  const [cursors, setCursors] = useState<Record<number, string>>({});
  
  // State for sorting and filtering
  const [sortModel, setSortModel] = useState(initialSortModel);
  const [filterModel, setFilterModel] = useState(initialFilterModel);
  
  // Convert sort model to sort string
  const sortString = sortModel.length > 0
    ? `${sortModel[0].sort === 'desc' ? '-' : ''}${sortModel[0].field}`
    : undefined;
  
  // Convert filter model to filter string
  const filterString = Object.keys(filterModel).length > 0
    ? JSON.stringify(filterModel)
    : undefined;
  
  // Prepare variables for GraphQL query
  const variables = {
    first: pageSize,
    after: page > 0 ? cursors[page - 1] : null,
    sort: sortString,
    filter: filterString,
    ...customVariables,
  };
  
  // Execute the query
  const { data, loading, error, refetch } = useQuery(query, {
    variables,
    notifyOnNetworkStatusChange: true,
    fetchPolicy: 'cache-and-network',
  });
  
  // Refetch when variables change
  useEffect(() => {
    refetch(variables);
  }, [page, pageSize, sortModel, filterModel, refetch]);
  
  // Extract data from query result
  const connection = data ? Object.values(data)[0] : null;
  
  // Process the data if it exists
  let rows: T[] = [];
  let totalCount = 0;
  
  if (connection && typeof connection === 'object' && connection !== null) {
    // Extract edges and convert to rows
    if ('edges' in connection && Array.isArray(connection.edges)) {
      rows = connection.edges.map((edge: any) => {
        // Transform the node into a row
        const row = nodeToRow(edge.node);
        
        // Ensure the row has an id property
        if (!('id' in row)) {
          (row as any).id = edge.node.accounting_mtm_history_id || edge.cursor;
        }
        
        return row;
      });
    }
    
    // Extract total count
    if ('totalCount' in connection && typeof connection.totalCount === 'number') {
      totalCount = connection.totalCount;
    }
    
    // Store cursors for pagination
    if ('pageInfo' in connection && connection.pageInfo?.endCursor) {
      setCursors(prev => ({
        ...prev,
        [page]: connection.pageInfo.endCursor,
      }));
    }
  }
  
  return {
    rows,
    totalRows: totalCount,
    loading,
    error: error as Error | null,
    setPage,
    setSortModel,
    setFilterModel,
  };
}
```

### 2. Update the Hook Index File

Update the hooks index file to export the new hook:

```typescript
// components/DataGrid/hooks/index.ts

export * from './useGraphQLData';
export * from './useRelayGraphQLData'; // Add this line
export * from './useGridNavigation';
export * from './useSelectionModel';
export * from './useServerSideData';
export * from './useGridValidation';
export * from './usePagination';
```

### 3. Modify the EnhancedDataGridGraphQL Component

Update the component to support both pagination styles:

```typescript
// components/DataGrid/EnhancedDataGridGraphQL.tsx

// Add a new prop to the interface
export interface EnhancedDataGridGraphQLProps<T = any> {
  // ... existing props
  
  // GraphQL options
  useGraphQL?: boolean;
  forceClientSide?: boolean;
  query?: DocumentNode;
  variables?: Record<string, any>;
  paginationStyle?: 'offset' | 'cursor'; // Add this line
  
  // ... other props
}

// In the component function
export function EnhancedDataGridGraphQL<T extends { id: GridRowId }>({
  // ... existing props
  
  // GraphQL options
  useGraphQL = true,
  forceClientSide = false,
  query,
  variables,
  paginationStyle = 'offset', // Add this line with default value
  
  // ... other props
}) {
  // ... existing code
  
  // Use GraphQL data if enabled and not forcing client-side
  const useGraphQLFetching = useGraphQL && !forceClientSide;
  
  // Determine which hook to use based on pagination style
  const isRelayCursorPagination = paginationStyle === 'cursor';
  
  // Use the appropriate hook based on pagination style
  const {
    rows: graphQLRows,
    totalRows: graphQLTotalRows,
    loading: graphQLLoading,
    setPage,
    setSortModel,
    setFilterModel,
  } = useGraphQLFetching
    ? (isRelayCursorPagination
      ? useRelayGraphQLData<T>({
          pageSize,
          initialPage: 0,
          initialSortModel: [],
          initialFilterModel: {},
          query,
          variables,
          nodeToRow: (node) => ({ ...node, id: node.accounting_mtm_history_id || node.id }),
        })
      : useGraphQLData<T>({
          pageSize,
          initialPage: 0,
          initialSortModel: [],
          initialFilterModel: {},
          query,
          variables,
        }))
    : { 
        rows: [] as T[], 
        totalRows: 0, 
        loading: false, 
        error: null, 
        setPage: () => {}, 
        setSortModel: () => {}, 
        setFilterModel: () => {} 
      };
  
  // ... rest of the component remains the same
}
```

### 4. Create a Test Page

Create a test page to verify the implementation:

```typescript
// pages/mtm-history.tsx

import React, { useState } from 'react';
import { GridRowId } from '@mui/x-data-grid';
import { Paper } from '@mui/material';
import { gql } from '@apollo/client';
import { EnhancedDataGridGraphQL } from '../components/DataGrid';

// GraphQL query using Relay-style pagination
const GET_MTM_HISTORY = gql`
  query MtmHistory(
    $first: Int
    $after: String
    $filter: String
    $sort: String
  ) {
    mtmHistory(first: $first, after: $after, filter: $filter, sort: $sort) {
      edges {
        cursor
        node {
          accounting_mtm_history_id
          adj_description 
          commodity
          deal_volume
        }
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
      totalCount
    }
  }
`;

// Define columns
const mtmHistoryColumns = [
  {
    field: 'accounting_mtm_history_id',
    headerName: 'ID',
    width: 120,
    fieldConfig: { type: 'string' as const },
  },
  {
    field: 'adj_description',
    headerName: 'Description',
    width: 200,
    fieldConfig: { type: 'string' as const },
  },
  {
    field: 'commodity',
    headerName: 'Commodity',
    width: 150,
    fieldConfig: { type: 'string' as const },
  },
  {
    field: 'deal_volume',
    headerName: 'Deal Volume',
    width: 150,
    fieldConfig: { type: 'number' as const },
  },
];

export default function MTMHistoryPage() {
  // State for grid
  const [selectionModel, setSelectionModel] = useState<GridRowId[]>([]);
  
  // Handler for selection changes
  const handleSelectionChange = (newSelection: GridRowId[]) => {
    setSelectionModel(newSelection);
  };
  
  return (
    <div className="h-full w-full flex flex-col p-4">
      <h1 className="text-2xl font-bold mb-4">MTM History</h1>
      
      {/* Data Grid */}
      <Paper elevation={0} className="flex-grow w-full overflow-auto">
        <EnhancedDataGridGraphQL
          columns={mtmHistoryColumns}
          rows={[]} // Empty array as fallback
          
          // GraphQL options
          useGraphQL={true}
          query={GET_MTM_HISTORY}
          paginationStyle="cursor" // Use cursor-based pagination
          
          // Selection options
          checkboxSelection={true}
          selectionModel={selectionModel}
          onSelectionModelChange={handleSelectionChange}
          
          // Grid capabilities
          canEditRows={false}
          canAddRows={false}
          canSelectRows={true}
          
          // UI options
          density="standard"
          disableSelectionOnClick={true}
          pageSize={25}
          rowsPerPageOptions={[10, 25, 50, 100]}
        />
      </Paper>
    </div>
  );
}
```

## Key Implementation Details

### Cursor Management

The `useRelayGraphQLData` hook maintains a mapping of page numbers to cursors. When a user navigates to a new page, the hook looks up the cursor for the previous page and uses it as the `after` parameter in the query.

### Data Transformation

The hook transforms the Relay-style response (with edges and nodes) into the format expected by the DataGrid component:

1. It extracts nodes from the edges array
2. It ensures each node has an `id` property (using `accounting_mtm_history_id` or the cursor)
3. It extracts the total count from the response

### Sorting and Filtering

The hook converts the DataGrid's sort and filter models into the format expected by the Relay-style query:

1. Sort model: Converted to a string with an optional `-` prefix for descending order
2. Filter model: Converted to a JSON string

## Testing the Implementation

To test the implementation:

1. Create the `useRelayGraphQLData` hook
2. Update the `EnhancedDataGridGraphQL` component
3. Create a test page that uses the component with the Relay-style query
4. Verify that pagination, sorting, and filtering work correctly

## Potential Challenges and Solutions

### Challenge: Cursor Tracking

Tracking cursors for pagination can be complex, especially when users jump between pages.

**Solution**: Maintain a mapping of page numbers to cursors and fetch missing cursors as needed.

### Challenge: Data Transformation

The Relay-style response structure is different from what the DataGrid expects.

**Solution**: Transform the data in the hook before returning it to the component.

### Challenge: Backward Compatibility

We need to support both pagination styles.

**Solution**: Add a `paginationStyle` prop to the component and use the appropriate hook based on the value.

## Conclusion

By implementing these changes, the `EnhancedDataGridGraphQL` component will be able to work with Relay-style cursor-based pagination while maintaining backward compatibility with the existing offset-based pagination.


====== docs/graphql-integration.md ======
Last Modified: 4/14/2025, 24:20 | Size: 12.9 KB | Lines: 471

# GraphQL Integration with EnhancedDataGridGraphQL

This document explains how the `EnhancedDataGridGraphQL` component integrates with GraphQL to provide server-side sorting, filtering, and pagination capabilities.

## Overview

The `EnhancedDataGridGraphQL` component is designed to work with both client-side and server-side data. When used with GraphQL, it leverages server-side operations for better performance with large datasets. The component accepts a GraphQL query and variables as props, making it flexible and reusable across different data sources.

## Component Architecture

The GraphQL integration consists of several key components:

1. **EnhancedDataGridGraphQL**: The main component that renders the data grid and handles user interactions.
2. **useGraphQLData**: A custom hook that manages the GraphQL data fetching, including pagination, sorting, and filtering.
3. **Apollo Client**: Used to execute GraphQL queries and manage the data cache.

## How to Use the Component with GraphQL

### Basic Usage

```tsx
import { gql } from '@apollo/client';
import { EnhancedDataGridGraphQL } from '../components/DataGrid';

// Define your GraphQL query
const GET_DATA = gql`
  query GetData(
    $page: Int
    $pageSize: Int
    $sort: SortInput
    $filter: FilterInput
  ) {
    data(
      page: $page
      pageSize: $pageSize
      sort: $sort
      filter: $filter
    ) {
      rows {
        id
        field1
        field2
        // ... other fields
      }
      totalRows
    }
  }
`;

// Define your columns
const columns = [
  {
    field: 'id',
    headerName: 'ID',
    width: 90,
    fieldConfig: { type: 'number' as const },
  },
  {
    field: 'field1',
    headerName: 'Field 1',
    width: 150,
    fieldConfig: { type: 'string' as const },
  },
  // ... other columns
];

// Use the component in your page/component
function MyDataGrid() {
  return (
    <EnhancedDataGridGraphQL
      columns={columns}
      rows={[]} // Fallback data if not using GraphQL
      useGraphQL={true} // Enable GraphQL fetching
      query={GET_DATA} // Pass the GraphQL query
      variables={{}} // Optional additional variables
      pageSize={25}
      // ... other props
    />
  );
}
```

### Props for GraphQL Integration

The `EnhancedDataGridGraphQL` component accepts the following props for GraphQL integration:

- `useGraphQL` (boolean): Whether to use GraphQL for data fetching.
- `forceClientSide` (boolean): Force client-side operations even when GraphQL is enabled.
- `query` (DocumentNode): The GraphQL query to execute.
- `variables` (object): Additional variables to pass to the GraphQL query.

## How Sorting, Filtering, and Pagination Work with GraphQL

### Server-Side Mode Configuration

The DataGrid is configured to use server-side mode for sorting, filtering, and pagination when GraphQL fetching is enabled:

```tsx
<DataGrid
  // ...other props
  paginationMode={useGraphQLFetching ? 'server' : 'client'}
  sortingMode={useGraphQLFetching ? 'server' : 'client'}
  filterMode={useGraphQLFetching ? 'server' : 'client'}
  // ...
/>
```

### Event Handlers for User Interactions

When users interact with the grid (sort columns, apply filters, change pages), the component captures these events and updates the GraphQL variables:

```tsx
// Pagination handler
onPaginationModelChange={(model) => {
  if (useGraphQLFetching) {
    setPage(model.page);
  }
}}

// Sorting handler
onSortModelChange={(model) => {
  if (useGraphQLFetching) {
    setSortModel(model.map(item => ({
      field: item.field,
      sort: item.sort as 'asc' | 'desc'
    })));
  }
}}

// Filtering handler
onFilterModelChange={(model) => {
  if (useGraphQLFetching) {
    const filterModel: Record<string, any> = {};
    model.items.forEach(item => {
      if (item.field && item.value !== undefined) {
        filterModel[item.field] = item.value;
      }
    });
    setFilterModel(filterModel);
  }
}}
```

### GraphQL Variables Construction

In the `useGraphQLData` hook, these state changes are used to construct the variables for the GraphQL query:

```tsx
// In useGraphQLData.ts
const variables = {
  page,
  pageSize,
  sort: sortModel.length > 0
    ? { field: sortModel[0].field, direction: sortModel[0].sort }
    : undefined,
  filter: Object.keys(filterModel).length > 0
    ? filterModel
    : undefined,
  ...customVariables, // Merge custom variables from props
};
```

### Data Refetching on State Changes

An effect hook triggers a refetch whenever any of these variables change:

```tsx
// In useGraphQLData.ts
useEffect(() => {
  refetch(variables);
}, [page, pageSize, sortModel, filterModel, refetch]);
```

### Data Flow to the Grid

The fetched data is then passed to the DataGrid:

```tsx
// In EnhancedDataGridGraphQL.tsx
const displayRows = useGraphQLFetching ? graphQLRows : rows;
const totalRows = useGraphQLFetching ? graphQLTotalRows : rows.length;

// ...

<DataGrid
  rows={displayRows}
  rowCount={totalRows}
  // ...
/>
```

## Complete Example: MTM Adjustments Grid

Here's a complete example of using the `EnhancedDataGridGraphQL` component with a GraphQL query for MTM Adjustments data:

```tsx
import React, { useState } from 'react';
import { GridRowId } from '@mui/x-data-grid';
import { Paper } from '@mui/material';
import { gql } from '@apollo/client';
import { EnhancedDataGridGraphQL } from '../components/DataGrid';
import { ValidationHelpers } from '../components/DataGrid/context/GridFormContext';

// Define types for MTM Adjustments
interface MTMAdjustment {
  id: number;
  deal_key: number;
  reporting_month: string;
  contract_month: string;
  contract_number: string;
  bucket_strategy: string;
  bs_netting_label: string;
  group_id: number;
  rolloff_classification: string;
  fas_161_label: string;
  strategy: string;
  fas_157_curve_rank: number;
  portfolio: string;
  modified_by: string;
  modified_on: string;
}

// GraphQL query for fetching MTMAdjustments with pagination, sorting, and filtering
const GET_MTM_ADJUSTMENTS = gql`
  query GetMTMAdjustments(
    $page: Int
    $pageSize: Int
    $sort: SortInput
    $filter: MTMAdjustmentFilterInput
  ) {
    mtmAdjustments(
      page: $page
      pageSize: $pageSize
      sort: $sort
      filter: $filter
    ) {
      rows {
        id
        deal_key
        reporting_month
        contract_month
        contract_number
        bucket_strategy
        bs_netting_label
        group_id
        rolloff_classification
        fas_161_label
        strategy
        fas_157_curve_rank
        portfolio
        modified_by
        modified_on
      }
      totalRows
    }
  }
`;

// Define columns for MTM Adjustments
const mtmAdjustmentColumns = [
  {
    field: 'id',
    headerName: 'ID',
    width: 90,
    fieldConfig: { type: 'number' as const },
  },
  {
    field: 'deal_key',
    headerName: 'Deal Key',
    width: 120,
    fieldConfig: { type: 'number' as const },
  },
  {
    field: 'reporting_month',
    headerName: 'Reporting Month',
    width: 150,
    fieldConfig: { type: 'string' as const },
  },
  // ... other columns
];

// Sample data for client-side fallback
const sampleMTMAdjustments: MTMAdjustment[] = [
  {
    id: 1,
    deal_key: 12345,
    reporting_month: '2023-01',
    contract_month: '2023-02',
    contract_number: 'CN-001',
    bucket_strategy: 'Strategy A',
    bs_netting_label: 'Label 1',
    group_id: 100,
    rolloff_classification: 'Class A',
    fas_161_label: 'Label X',
    strategy: 'Hedge',
    fas_157_curve_rank: 2,
    portfolio: 'Portfolio A',
    modified_by: 'John Doe',
    modified_on: '2023-01-15',
  },
  // ... other sample data
];

export default function MTMAdjustmentsPage() {
  // State for grid
  const [selectionModel, setSelectionModel] = useState<GridRowId[]>([]);
  const [useGraphQLFetching, setUseGraphQLFetching] = useState(true);
  
  // Row-level validation for MTM Adjustment data
  const validateMTMAdjustmentRow = (values: any, helpers: ValidationHelpers) => {
    const errors: Record<string, string> = {};
    // Add validation logic as needed
    return errors;
  };

  // Handle save function
  const handleSave = (changes: { edits: any[], additions: any[] }) => {
    console.log('Saving changes:', changes);
    // Submit changes to API
  };
  
  // Handler for selection changes
  const handleSelectionChange = (newSelection: GridRowId[]) => {
    setSelectionModel(newSelection);
  };

  // Custom variables for the GraphQL query
  const variables = {
    // Any additional variables needed for the query
  };

  return (
    <div className="h-full w-full flex flex-col p-4">
      <h1 className="text-2xl font-bold mb-4">MTM Adjustments</h1>
      
      <div className="mb-4">
        <label className="flex items-center">
          <input
            type="checkbox"
            checked={useGraphQLFetching}
            onChange={(e) => setUseGraphQLFetching(e.target.checked)}
            className="mr-2"
          />
          Use GraphQL Fetching
        </label>
      </div>
      
      {/* Data Grid */}
      <Paper elevation={0} className="flex-grow w-full overflow-auto">
        <EnhancedDataGridGraphQL
          columns={mtmAdjustmentColumns}
          rows={sampleMTMAdjustments} // Used as fallback when not using GraphQL
          onSave={handleSave}
          validateRow={validateMTMAdjustmentRow}
          
          // GraphQL options
          useGraphQL={useGraphQLFetching}
          query={GET_MTM_ADJUSTMENTS} // Pass the GraphQL query
          variables={variables} // Pass variables for the query
          
          // Selection options
          checkboxSelection={true}
          selectionModel={selectionModel}
          onSelectionModelChange={handleSelectionChange}
          
          // Grid capabilities
          canEditRows={true}
          canAddRows={true}
          canSelectRows={true}
          
          // UI options
          density="standard"
          disableSelectionOnClick={true}
          pageSize={25}
          rowsPerPageOptions={[10, 25, 50, 100]}
        />
      </Paper>
    </div>
  );
}
```

## Implementation Details

### useGraphQLData Hook

The `useGraphQLData` hook is responsible for managing the GraphQL data fetching. Here's a simplified version of the hook:

```tsx
import { useState, useEffect } from 'react';
import { useQuery } from '@apollo/client';
import { ServerSideResult } from '../types/serverSide';

export function useGraphQLData<T>({
  pageSize,
  initialPage = 0,
  initialSortModel = [],
  initialFilterModel = {},
  query,
  variables: customVariables = {},
}: {
  pageSize: number;
  initialPage?: number;
  initialSortModel?: { field: string; sort: 'asc' | 'desc' }[];
  initialFilterModel?: Record<string, any>;
  query?: any; // DocumentNode from Apollo
  variables?: Record<string, any>;
}): ServerSideResult<T> {
  const [page, setPage] = useState(initialPage);
  const [sortModel, setSortModel] = useState(initialSortModel);
  const [filterModel, setFilterModel] = useState(initialFilterModel);

  // Prepare variables for GraphQL query
  const variables = {
    page,
    pageSize,
    sort: sortModel.length > 0
      ? { field: sortModel[0].field, direction: sortModel[0].sort }
      : undefined,
    filter: Object.keys(filterModel).length > 0
      ? filterModel
      : undefined,
    ...customVariables, // Merge custom variables
  };

  // Execute the query - use custom query if provided, otherwise use default
  const { data, loading, error, refetch } = useQuery(query, {
    variables,
    notifyOnNetworkStatusChange: true,
    fetchPolicy: 'cache-and-network',
  });

  // Refetch when variables change
  useEffect(() => {
    refetch(variables);
  }, [page, pageSize, sortModel, filterModel, refetch]);

  // Extract data from query result
  // Safely access rows and totalRows with type assertions
  const queryResult = data ? Object.values(data)[0] : null;
  
  const rows = queryResult && typeof queryResult === 'object' && queryResult !== null && 'rows' in queryResult 
    ? (queryResult as any).rows 
    : [];
  const totalRows = queryResult && typeof queryResult === 'object' && queryResult !== null && 'totalRows' in queryResult 
    ? (queryResult as any).totalRows 
    : 0;

  return {
    rows: rows as T[],
    totalRows,
    loading,
    error: error as Error | null,
    setPage,
    setSortModel,
    setFilterModel,
  };
}
```

## Benefits of GraphQL Integration

1. **Efficient Data Loading**: Only fetches the data needed for the current view.
2. **Reduced Network Traffic**: Server-side sorting, filtering, and pagination reduce the amount of data transferred.
3. **Better Performance**: Especially noticeable with large datasets.
4. **Flexibility**: Can work with different GraphQL schemas by passing custom queries.
5. **Seamless User Experience**: Loading states are handled automatically.

## Conclusion

The GraphQL integration with `EnhancedDataGridGraphQL` provides a powerful and flexible way to work with server-side data. By leveraging GraphQL's capabilities for data fetching, sorting, filtering, and pagination, the component delivers a smooth user experience even with large datasets.


====== docs/eslint-guide.md ======
Last Modified: 4/11/2025, 16:54 | Size: 4.1 KB | Lines: 152

# ESLint Configuration Guide

## Overview

We've configured ESLint to check for unused variables and other code quality issues. The configuration is in `eslint.config.mjs` using the new flat config format.

## Current Configuration

The ESLint configuration has been set up to:

1. Extend Next.js recommended configurations (`next/core-web-vitals` and `next/typescript`)
2. Check for unused variables with error severity
3. Check for unused expressions
4. Apply TypeScript-specific rules for unused variables

## Available Scripts

- `npm run lint`: Run ESLint to check for issues
- `npm run lint:fix`: Run ESLint with auto-fix enabled
- `npm run lint:unused`: Run ESLint with zero tolerance for warnings
- `npm run lint:remove-unused`: Automatically remove unused variables from code

## Common Issues and How to Fix Them

### 1. Unused Variables

ESLint is configured to report errors for unused variables. There are several ways to fix these:

- **Remove the variable** if it's not needed (recommended approach)
  ```typescript
  // Before
  function example(unusedParam) {
    // ...
  }
  
  // After
  function example() {
    // ...
  }
  ```

- **Use the variable** if it's actually needed

- **Prefix with underscore** (`_`) as a last resort if the variable must be kept for API compatibility:
  ```typescript
  function example(_unusedParam) {
    // ...
  }
  ```

You can use the `npm run lint:remove-unused` script to automatically remove many unused variables from your code. The script handles:
- Import statements
- Function parameters
- Destructuring assignments
- Variable declarations

Note that some complex cases may require manual review.

### 2. TypeScript `any` Type

Many errors are related to the use of `any` type. To fix these:

- Replace `any` with a more specific type:
  ```typescript
  // Before
  function process(data: any) {
    // ...
  }
  
  // After
  interface DataType {
    id: string;
    value: number;
  }
  
  function process(data: DataType) {
    // ...
  }
  ```
- If the exact type is unknown, use `unknown` instead of `any`:
  ```typescript
  function process(data: unknown) {
    // Type guard before using
    if (typeof data === 'object' && data !== null && 'id' in data) {
      // Now TypeScript knows more about the shape
    }
  }
  ```
- For component props, create proper interfaces:
  ```typescript
  interface MyComponentProps {
    value: string;
    onChange: (value: string) => void;
  }
  
  function MyComponent({ value, onChange }: MyComponentProps) {
    // ...
  }
  ```

### 3. React Hook Dependency Issues

ESLint warns about missing dependencies in React hooks. To fix these:

- Add the missing dependency to the dependency array:
  ```typescript
  // Before
  useEffect(() => {
    doSomething(value);
  }, []); // Missing dependency: value
  
  // After
  useEffect(() => {
    doSomething(value);
  }, [value]);
  ```
- If adding the dependency would cause an infinite loop, consider:
  - Using `useRef` for values that shouldn't trigger re-renders
  - Using `useCallback` to memoize functions
  - Using `useMemo` to memoize values

### 4. Unescaped Entities in JSX

Replace unescaped entities with their HTML entity codes:

```jsx
// Before
<p>Don't use unescaped entities</p>

// After
<p>Don&apos;t use unescaped entities</p>
```

## Systematic Approach to Fixing Issues

1. Start with the most critical files (core components, frequently used utilities)
2. Fix one type of issue at a time (e.g., fix all unused variables first)
3. Run `npm run lint` after each set of changes to verify progress
4. Commit changes in logical groups

## Best Practices Going Forward

1. **Avoid using `any` type** - Always define proper types or interfaces
2. **Prefix unused parameters with underscore** - This signals intent and satisfies ESLint
3. **Pay attention to React Hook dependencies** - Ensure all used variables are in the dependency array
4. **Run ESLint before committing** - Catch issues early

## Additional Resources

- [ESLint Documentation](https://eslint.org/docs/latest/)
- [TypeScript ESLint Rules](https://typescript-eslint.io/rules/)
- [React Hooks ESLint Plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks)


====== docs/unified-toolbar-design.md ======
Last Modified: 4/11/2025, 06:31 | Size: 22.0 KB | Lines: 779

# Unified DataGrid Toolbar Design

## Overview

This document outlines the design for a unified toolbar that integrates existing functionality with new modal features for editing, adding, and selection status. The toolbar will enforce a modal approach where only one mode can be active at a time.

## Requirements

1. The toolbar should have different modes (none, edit, add, select) where only one can be active at a time
2. When in edit mode:
   - The add button should be disabled
   - All other toolbar buttons (filter, export, etc.) should be disabled
   - Row selection checkboxes should be disabled
3. When in add mode:
   - Cell editing should be disabled for existing rows
   - All other toolbar buttons (filter, export, etc.) should be disabled
   - Row selection checkboxes should be disabled
4. Only show confirmation when switching from selection mode with more than 1 row selected
5. The status panel should be integrated into the toolbar and show different content based on the current mode
6. Pagination controls should be on the right side of the toolbar

## Component Structure

```mermaid
graph TD
    A[UnifiedDataGridToolbar] --> B[LeftSection: Mode Controls]
    A --> C[MiddleSection: Action Buttons]
    A --> D[RightSection: Status & Pagination]
    
    B --> B1[Edit Mode Button]
    B --> B2[Add Mode Button]
    B --> B3[Select Mode Button]
    
    C --> C1[Save Button]
    C --> C2[Filter Button]
    C --> C3[Export Button]
    C --> C4[Upload Button]
    C --> C5[Help Button]
    
    D --> D1[Mode Status Panel]
    D --> D2[Pagination Controls]
    
    D1 --> E1[Edit Status]
    D1 --> E2[Add Status]
    D1 --> E3[Select Status]
    D1 --> E4[None Status]
```

## State Management

We'll create a new context to manage the modal state of the toolbar:

```typescript
// ToolbarModeContext.tsx
type ToolbarMode = 'none' | 'edit' | 'add' | 'select';

interface ToolbarModeContextType {
  // Mode state
  mode: ToolbarMode;
  setMode: (newMode: ToolbarMode) => void;
  
  // Selection state
  selectedRowCount: number;
  clearSelection: () => void;
  
  // Edit state
  editingRowCount: number;
  isAddingRow: boolean;
  hasValidationErrors: boolean;
  
  // Actions
  saveChanges: () => void;
  cancelChanges: () => void;
  addRow: () => void;
  
  // Pagination
  page: number;
  pageSize: number;
  totalRows: number;
  setPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
}
```

This context will integrate with the existing GridFormContext and handle the modal behavior.

## Mode Status Panel

The Mode Status Panel will change based on the current mode:

### Edit Mode Status
- Shows number of records being edited
- Shows validation status
- Provides save/cancel buttons

### Add Mode Status
- Shows "Adding new record" status
- Shows validation status
- Provides save/cancel buttons

### Select Mode Status
- Shows number of selected rows
- Provides actions for selected rows (e.g., delete, export)

### None Mode Status
- Shows basic information or is hidden

## Modal Behavior Implementation

```typescript
// Handle mode switching with confirmation when needed
const handleModeSwitch = (newMode: ToolbarMode) => {
  // If in selection mode with multiple rows selected, show confirmation
  if (mode === 'select' && selectedRowCount > 1 && newMode !== 'select') {
    setConfirmationDialogOpen(true);
    setTargetMode(newMode);
    return;
  }
  
  // Otherwise, switch mode directly
  setMode(newMode);
};

// Determine button disabled states based on current mode
const isInEditOrAddMode = mode === 'edit' || mode === 'add';
const isAddButtonDisabled = mode === 'edit';
const isEditingEnabled = mode !== 'add';
const isSelectionEnabled = !isInEditOrAddMode;

// Disable all action buttons when in edit or add mode
const areActionButtonsDisabled = isInEditOrAddMode;
```

## Confirmation Dialog

```typescript
// Confirmation dialog for switching from selection mode
<Dialog open={confirmationDialogOpen} onClose={() => setConfirmationDialogOpen(false)}>
  <DialogTitle>Confirm Mode Switch</DialogTitle>
  <DialogContent>
    <DialogContentText>
      You have {selectedRowCount} rows selected. Switching to {targetMode} mode will clear your selection. Do you want to continue?
    </DialogContentText>
  </DialogContent>
  <DialogActions>
    <Button onClick={() => setConfirmationDialogOpen(false)}>Cancel</Button>
    <Button 
      onClick={() => {
        setMode(targetMode);
        clearSelection();
        setConfirmationDialogOpen(false);
      }} 
      color="primary"
    >
      Continue
    </Button>
  </DialogActions>
</Dialog>
```

## Integration with Existing Components

The unified toolbar will need to integrate with:

1. **GridFormContext**: For editing state, validation, and save/cancel actions
2. **useSelectionModel**: For selection state and actions
3. **usePagination**: For pagination state and controls
4. **DataGrid**: To control cell editing and row selection based on mode

## Component Implementation

### UnifiedDataGridToolbar Component

```typescript
import React, { useState } from 'react';
import {
  Box,
  IconButton,
  Tooltip,
  ToggleButtonGroup,
  ToggleButton,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Button,
  Chip,
  Select,
  MenuItem,
  Paper,
} from '@mui/material';

// Mode icons
import EditIcon from '@mui/icons-material/Edit';
import AddIcon from '@mui/icons-material/Add';
import SelectAllIcon from '@mui/icons-material/SelectAll';

// Pagination icons
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';

// Existing toolbar icons
import SaveIcon from '@mui/icons-material/Save';
import FilterAltIcon from '@mui/icons-material/FilterAlt';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import UploadIcon from '@mui/icons-material/Upload';
import HelpIcon from '@mui/icons-material/Help';
import CloseIcon from '@mui/icons-material/Close';

// Context and hooks
import { useToolbarMode } from '../context/ToolbarModeContext';
import { useGridForm } from '../context/GridFormContext';

interface UnifiedDataGridToolbarProps {
  onSave?: () => void;
  onFilter?: () => void;
  onExport?: () => void;
  onUpload?: () => void;
  onHelp?: () => void;
}

export const UnifiedDataGridToolbar: React.FC<UnifiedDataGridToolbarProps> = ({
  onSave,
  onFilter,
  onExport,
  onUpload,
  onHelp
}) => {
  // Get toolbar mode context
  const {
    mode,
    setMode,
    selectedRowCount,
    clearSelection,
    editingRowCount,
    isAddingRow,
    hasValidationErrors,
    saveChanges,
    cancelChanges,
    addRow,
    page,
    pageSize,
    totalRows,
    setPage,
    setPageSize
  } = useToolbarMode();

  // State for confirmation dialog
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const [targetMode, setTargetMode] = useState<'none' | 'edit' | 'add' | 'select'>('none');

  // Handle mode switching with confirmation when needed
  const handleModeSwitch = (newMode: 'none' | 'edit' | 'add' | 'select') => {
    // If in selection mode with multiple rows selected, show confirmation
    if (mode === 'select' && selectedRowCount > 1 && newMode !== 'select') {
      setConfirmationDialogOpen(true);
      setTargetMode(newMode);
      return;
    }
    
    // Otherwise, switch mode directly
    setMode(newMode);
  };

  // Determine button disabled states based on current mode
  const isInEditOrAddMode = mode === 'edit' || mode === 'add';
  const isAddButtonDisabled = mode === 'edit';
  const areActionButtonsDisabled = isInEditOrAddMode;

  return (
    <Box sx={{ 
      display: 'flex', 
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: 1,
      borderBottom: '1px solid #e0e0e0'
    }}>
      {/* Left Section: Mode Controls */}
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <ToggleButtonGroup
          value={mode}
          exclusive
          onChange={(_, newMode) => {
            if (newMode !== null) {
              handleModeSwitch(newMode);
            }
          }}
          size="small"
        >
          <ToggleButton value="edit" disabled={isAddingRow}>
            <EditIcon fontSize="small" />
            <Typography variant="body2" sx={{ ml: 0.5 }}>Edit</Typography>
          </ToggleButton>
          <ToggleButton value="add" disabled={isAddButtonDisabled}>
            <AddIcon fontSize="small" />
            <Typography variant="body2" sx={{ ml: 0.5 }}>Add</Typography>
          </ToggleButton>
          <ToggleButton value="select">
            <SelectAllIcon fontSize="small" />
            <Typography variant="body2" sx={{ ml: 0.5 }}>Select</Typography>
          </ToggleButton>
        </ToggleButtonGroup>
      </Box>

      {/* Middle Section: Action Buttons */}
      <Box sx={{ 
        display: 'flex', 
        justifyContent: 'center',
        gap: 1
      }}>
        {/* Save Options */}
        <Tooltip title="Save">
          <span>
            <IconButton onClick={onSave} disabled={areActionButtonsDisabled}>
              <SaveIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* Filter Options */}
        <Tooltip title="Filter">
          <span>
            <IconButton onClick={onFilter} disabled={areActionButtonsDisabled}>
              <FilterAltIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* Export Options */}
        <Tooltip title="Export">
          <span>
            <IconButton onClick={onExport} disabled={areActionButtonsDisabled}>
              <FileDownloadIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* Upload Options */}
        <Tooltip title="Upload">
          <span>
            <IconButton onClick={onUpload} disabled={areActionButtonsDisabled}>
              <UploadIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* Help Options */}
        <Tooltip title="Help">
          <span>
            <IconButton onClick={onHelp} disabled={areActionButtonsDisabled}>
              <HelpIcon />
            </IconButton>
          </span>
        </Tooltip>
      </Box>

      {/* Right Section: Status & Pagination */}
      <Box sx={{ 
        display: 'flex', 
        alignItems: 'center',
        gap: 2
      }}>
        {/* Mode Status Panel */}
        {mode !== 'none' && (
          <Paper
            elevation={0}
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: 1,
              padding: '4px 8px',
              borderRadius: 1,
              backgroundColor: mode === 'edit' ? 'rgba(25, 118, 210, 0.08)' : 
                              mode === 'add' ? 'rgba(46, 125, 50, 0.08)' : 
                              'rgba(237, 108, 2, 0.08)'
            }}
          >
            {/* Status content based on mode */}
            {mode === 'edit' && (
              <>
                <Typography variant="body2">
                  Editing {editingRowCount} record{editingRowCount !== 1 ? 's' : ''}
                </Typography>
                {hasValidationErrors && (
                  <Chip 
                    label="Validation errors" 
                    size="small" 
                    color="warning" 
                    sx={{ height: 24 }}
                  />
                )}
                <Tooltip title="Save changes">
                  <IconButton size="small" onClick={saveChanges} disabled={hasValidationErrors}>
                    <SaveIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Cancel changes">
                  <IconButton size="small" onClick={cancelChanges}>
                    <CloseIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </>
            )}
            
            {mode === 'add' && (
              <>
                <Typography variant="body2">
                  Adding new record
                </Typography>
                {hasValidationErrors && (
                  <Chip 
                    label="Validation errors" 
                    size="small" 
                    color="warning" 
                    sx={{ height: 24 }}
                  />
                )}
                <Tooltip title="Save changes">
                  <IconButton size="small" onClick={saveChanges} disabled={hasValidationErrors}>
                    <SaveIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <Tooltip title="Cancel changes">
                  <IconButton size="small" onClick={cancelChanges}>
                    <CloseIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </>
            )}
            
            {mode === 'select' && (
              <>
                <Typography variant="body2">
                  {selectedRowCount} row{selectedRowCount !== 1 ? 's' : ''} selected
                </Typography>
                <Tooltip title="Clear selection">
                  <IconButton size="small" onClick={clearSelection}>
                    <CloseIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </>
            )}
          </Paper>
        )}

        {/* Pagination Controls */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Typography variant="body2">
            Page {page + 1} of {Math.ceil(totalRows / pageSize)}
          </Typography>
          <IconButton 
            size="small"
            disabled={page === 0} 
            onClick={() => setPage(page - 1)}
          >
            <ChevronLeftIcon fontSize="small" />
          </IconButton>
          <IconButton 
            size="small"
            disabled={page >= Math.ceil(totalRows / pageSize) - 1} 
            onClick={() => setPage(page + 1)}
          >
            <ChevronRightIcon fontSize="small" />
          </IconButton>
          <Select
            value={pageSize}
            onChange={(e) => setPageSize(Number(e.target.value))}
            size="small"
            sx={{ height: 28, minWidth: 80 }}
          >
            {[10, 25, 50, 100].map((size) => (
              <MenuItem key={size} value={size}>
                {size} rows
              </MenuItem>
            ))}
          </Select>
        </Box>
      </Box>

      {/* Confirmation Dialog */}
      <Dialog 
        open={confirmationDialogOpen} 
        onClose={() => setConfirmationDialogOpen(false)}
      >
        <DialogTitle>Confirm Mode Switch</DialogTitle>
        <DialogContent>
          <DialogContentText>
            You have {selectedRowCount} rows selected. Switching to {targetMode} mode will clear your selection. Do you want to continue?
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setConfirmationDialogOpen(false)}>Cancel</Button>
          <Button 
            onClick={() => {
              setMode(targetMode);
              clearSelection();
              setConfirmationDialogOpen(false);
            }} 
            color="primary"
          >
            Continue
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};
```

### ToolbarModeContext

```typescript
import React, { createContext, useContext, useState, useCallback } from 'react';
import { useGridForm } from './GridFormContext';
import { useSelectionModel } from '../hooks/useSelectionModel';
import { usePagination } from '../hooks/usePagination';

// Define the toolbar mode type
type ToolbarMode = 'none' | 'edit' | 'add' | 'select';

// Define the context type
interface ToolbarModeContextType {
  // Mode state
  mode: ToolbarMode;
  setMode: (newMode: ToolbarMode) => void;
  
  // Selection state
  selectedRowCount: number;
  clearSelection: () => void;
  
  // Edit state
  editingRowCount: number;
  isAddingRow: boolean;
  hasValidationErrors: boolean;
  
  // Actions
  saveChanges: () => void;
  cancelChanges: () => void;
  addRow: () => void;
  
  // Pagination
  page: number;
  pageSize: number;
  totalRows: number;
  setPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
}

// Create the context
const ToolbarModeContext = createContext<ToolbarModeContextType | undefined>(undefined);

// Provider props
interface ToolbarModeProviderProps {
  children: React.ReactNode;
  totalRows: number;
}

// Provider component
export const ToolbarModeProvider: React.FC<ToolbarModeProviderProps> = ({ 
  children,
  totalRows
}) => {
  // State for the current mode
  const [mode, setMode] = useState<ToolbarMode>('none');
  
  // Get form context
  const { 
    saveChanges: formSaveChanges,
    cancelChanges: formCancelChanges,
    addRow: formAddRow,
    hasValidationErrors,
    editingRows
  } = useGridForm();
  
  // Get selection model
  const { 
    selectionModel,
    onSelectionModelChange
  } = useSelectionModel();
  
  // Get pagination
  const {
    page,
    pageSize,
    setPage,
    setPageSize
  } = usePagination();
  
  // Derived state
  const selectedRowCount = selectionModel.length;
  const editingRowCount = editingRows.size;
  const isAddingRow = Array.from(editingRows).some(rowId => {
    // Check if this is a newly added row (implementation depends on how you track added rows)
    return typeof rowId === 'string' && rowId.startsWith('new-');
  });
  
  // Clear selection
  const clearSelection = useCallback(() => {
    onSelectionModelChange([], { api: null });
  }, [onSelectionModelChange]);
  
  // Save changes
  const saveChanges = useCallback(() => {
    formSaveChanges();
    setMode('none');
  }, [formSaveChanges]);
  
  // Cancel changes
  const cancelChanges = useCallback(() => {
    formCancelChanges();
    setMode('none');
  }, [formCancelChanges]);
  
  // Add row
  const addRow = useCallback(() => {
    formAddRow();
    setMode('add');
  }, [formAddRow]);
  
  // Context value
  const contextValue: ToolbarModeContextType = {
    mode,
    setMode,
    selectedRowCount,
    clearSelection,
    editingRowCount,
    isAddingRow,
    hasValidationErrors,
    saveChanges,
    cancelChanges,
    addRow,
    page,
    pageSize,
    totalRows,
    setPage,
    setPageSize
  };
  
  return (
    <ToolbarModeContext.Provider value={contextValue}>
      {children}
    </ToolbarModeContext.Provider>
  );
};

// Hook to use the context
export const useToolbarMode = () => {
  const context = useContext(ToolbarModeContext);
  if (!context) {
    throw new Error('useToolbarMode must be used within a ToolbarModeProvider');
  }
  return context;
};
```

## Integration with EnhancedDataGrid

The EnhancedDataGrid component will need to be updated to:

1. Wrap its children with the ToolbarModeProvider
2. Replace the existing toolbar with the UnifiedDataGridToolbar
3. Pass the appropriate props to control the modal behavior
4. Disable row selection checkboxes when in edit or add mode
5. Disable cell editing when in add mode for existing rows

```typescript
// In EnhancedDataGrid.tsx

// Add the UnifiedDataGridToolbar
import { UnifiedDataGridToolbar } from './components/UnifiedDataGridToolbar';
import { ToolbarModeProvider, useToolbarMode } from './context/ToolbarModeContext';

// Inside the component
return (
  <ToolbarModeProvider totalRows={totalRows}>
    <GridFormProvider
      columns={columns}
      initialRows={displayRows}
      onSave={onSave}
      validateRow={validateRow}
      isCompact={isCompact}
    >
      <div className={`h-full w-full flex flex-col ${className || ''}`}>
        {/* Replace the existing toolbar and header with the unified toolbar */}
        <UnifiedDataGridToolbar
          onSave={onSave}
          onFilter={onFilter}
          onExport={onExport}
          onUpload={onUpload}
          onHelp={onHelp}
        />
        
        <Paper elevation={0} className="flex-grow w-full overflow-auto">
          <CellEditHandler apiRef={apiRef} />
          <DataGridWithModeControl
            apiRef={apiRef}
            rows={displayRows}
            columns={gridColumns}
            // ... other props
          />
        </Paper>
      </div>
    </GridFormProvider>
  </ToolbarModeProvider>
);

// Create a wrapper component to access the mode context
const DataGridWithModeControl = (props) => {
  const { mode } = useToolbarMode();
  
  // Determine if row selection should be disabled
  const isInEditOrAddMode = mode === 'edit' || mode === 'add';
  
  return (
    <DataGrid
      {...props}
      checkboxSelection={props.checkboxSelection && !isInEditOrAddMode}
      disableRowSelectionOnClick={isInEditOrAddMode || props.disableRowSelectionOnClick}
      onCellClick={(params) => {
        // Disable cell editing when in add mode for existing rows
        if (mode === 'add' && !params.id.toString().startsWith('new-')) {
          return;
        }
        
        // Original cell click handler
        if (params.field !== '__check__' && params.field !== '__actions__') {
          const { id, field } = params;
          const column = props.columns.find(col => col.field === field);
          if (column?.editable !== false) {
            try {
              const cellMode = props.apiRef.current.getCellMode(id, field);
              if (cellMode === 'view') {
                props.apiRef.current.startCellEditMode({ id, field });
              }
            } catch (error) {
              console.error('Error starting cell edit mode:', error);
            }
          }
        }
      }}
    />
  );
};
```

## Data Flow Diagram

```mermaid
graph TD
    A[ToolbarModeContext] --> B[UnifiedDataGridToolbar]
    C[GridFormContext] --> B
    D[useSelectionModel] --> B
    E[usePagination] --> B
    
    B --> F[EnhancedDataGrid]
    
    A --> F
    C --> F
    D --> F
    E --> F
    
    F --> G[DataGrid]
```

## Implementation Plan

1. Create the `ToolbarModeContext.tsx` file
2. Create the `UnifiedDataGridToolbar.tsx` component
3. Update the `EnhancedDataGrid.tsx` component to use the new toolbar and context
4. Update the `GridFormContext.tsx` to expose the necessary state and methods
5. Update the `useSelectionModel.ts` hook to support clearing selection
6. Test the implementation with various scenarios:
   - Switching between modes
   - Editing rows
   - Adding rows
   - Selecting rows
   - Pagination


====== docs/refactoring-progress.md ======
Last Modified: 4/11/2025, 06:19 | Size: 3.1 KB | Lines: 80

# Refactoring Progress

This document tracks the progress of the refactoring effort to make the React DataGrid project more maintainable and AI-friendly.

## Completed Tasks

### Phase 1: Documentation and Cleanup

#### Documentation
- ✅ Added detailed inline comments to `EnhancedDataGridDemo.tsx`
  - Documented state management and data flow
  - Explained column definitions and validation rules
  - Clarified component rendering and props
  - Added JSDoc-style comments for key functions

- ✅ Added comprehensive documentation to `GridModeContext.tsx`
  - Explained the grid mode system and its purpose
  - Documented selection model management
  - Clarified editing rows tracking logic
  - Added context for derived state calculations
  - Documented action handlers and their effects

#### Dead Code Removal
- ✅ Identified and removed unused files
  - `components/UnifiedToolbarDataGridDemo.tsx` (backed up)
  - `components/DataGridToolbar.tsx` (backed up)
  
- ✅ Updated references
  - Modified `pages/unified-toolbar.tsx` to use `EnhancedDataGridDemo`
  - Removed unused imports from `EnhancedDataGridDemo.tsx`

## Fixes Implemented

### Bug Fixes
- ✅ Fixed issue with "Add" button not being hidden when `canAddRows` is set to `false`
  - Problem: The Add button was always showing in the toolbar even when `canAddRows` was set to `false`
  - Solution: Explicitly set `canAddRows={false}` in `EnhancedDataGridDemo.tsx`
  - Added documentation about the Grid Capabilities flow in `docs/data-flow-documentation.md`

## Issues Encountered

### Type Compatibility Issues
- During our refactoring, we encountered TypeScript errors related to type compatibility between the `GridModeContext` and the `useSelectionModel` hook.
- The `onSelectionModelChange` function has different type signatures in different parts of the codebase:
  - In `SelectionModelState`, it expects two parameters: `(newSelectionModel: GridRowSelectionModel, details: GridCallbackDetails) => void`
  - In `SelectionOptions`, it expects only one parameter: `(selectionModel: any[]) => void`
- Fixing these issues would require more extensive changes to the type system, which we've deferred to Phase 5 (Type Safety Enhancements).

## Next Steps

### Continue Phase 1
- [ ] Add inline comments to `GridFormContext.tsx`
- [ ] Add inline comments to key renderer components
- [ ] Clean up unused variables and debug console.logs

### Phase 2: Context System Consolidation
- [ ] Create new context structure
- [ ] Migrate functionality from old contexts
- [ ] Update components to use new contexts

### Phase 3: Component Restructuring
- [ ] Break down EnhancedDataGrid
- [ ] Simplify component props
- [ ] Improve component composition

### Phase 4: State Management Improvements
- [ ] Normalize state structure
- [ ] Extract validation logic
- [ ] Improve state updates

### Phase 5: Type Safety Enhancements
- [ ] Improve type definitions
- [ ] Reduce `any` types
- [ ] Add type documentation

## Notes

- The backup of removed files is stored in the `backup` directory with documentation
- The unified toolbar page now uses the main EnhancedDataGridDemo component
- We've maintained backward compatibility while improving code quality


====== docs/unused-code-analysis.md ======
Last Modified: 4/11/2025, 06:19 | Size: 10.8 KB | Lines: 394

# Unused Code Analysis

This document identifies unused variables, imports, and code blocks in the React DataGrid codebase. Removing these unused elements will improve code maintainability, reduce bundle size, and make the codebase more AI-friendly.

## Table of Contents

1. [Unused Variables](#1-unused-variables)
2. [Unused Imports](#2-unused-imports)
3. [Dead Code Blocks](#3-dead-code-blocks)
4. [Commented-Out Code](#4-commented-out-code)
5. [Redundant Code](#5-redundant-code)

## 1. Unused Variables

### EnhancedDataGridDemo.tsx

```typescript
// Line 9: State for server-side mode and selection
const [serverSide, setServerSide] = useState(true);
```

This `serverSide` state is defined but only used once to conditionally set the `dataUrl` prop. The `setServerSide` function is never used, indicating this was likely meant to be a configurable option but the UI for toggling it was never implemented.

```typescript
// Lines 137-155: Handler functions defined but not connected to UI
const handleFilter = () => {
  console.log('Filter clicked');
};

const handleRefresh = () => {
  console.log('Refresh clicked');
};

const handleExport = () => {
  console.log('Export clicked');
};

const handleUpload = () => {
  console.log('Upload clicked');
};

const handleHelp = () => {
  console.log('Help clicked');
};
```

These handler functions are defined but not passed to any components or event listeners. They appear to be placeholder functions for toolbar actions that were never fully implemented in this component.

### GridModeContext.tsx

```typescript
// Line 76-78: Props defined but not used in component logic
// Grid capabilities
canEditRows = true,
canAddRows = true,
canSelectRows = true
```

These props are defined in the component parameters but not used in the component logic. They appear to be intended for controlling UI behavior but aren't actually implemented.

### UnifiedDataGridToolbar.tsx

```typescript
// Line 86-92: Debug logging that's not needed in production
// Debug: Log selection model changes
console.log('UnifiedDataGridToolbar - selectionModel from context:', selectionModel);

// Add a visual indicator for debugging
if (!selectionModel || selectionModel.length === 0) {
  console.log('No selection model or empty selection model');
}
```

These debug log statements should be removed in production code.

## 2. Unused Imports

### EnhancedDataGridDemo.tsx

```typescript
// Line 2: Unused imports
import { Box, Typography, FormControlLabel, Switch, Chip } from '@mui/material';
```

The `FormControlLabel`, `Switch`, and `Chip` components are imported but never used in the file. Only `Box` and `Typography` are actually used.

### GridFormContext.tsx

```typescript
// Line 1: Unused import
import React, { createContext, useCallback, useContext, useState, useRef, useEffect } from 'react';
```

The `useEffect` hook is imported but not used in some parts of the file.

### UnifiedDataGridToolbar.tsx

```typescript
// Lines 4-19: Many unused imports
import {
  Box,
  IconButton,
  Tooltip,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Button,
  Chip,
  Select,
  MenuItem,
  Paper,
  SelectChangeEvent,
  Divider,
} from '@mui/material';
```

Several of these imports are not used in the component, such as `SelectChangeEvent`.

## 3. Dead Code Blocks

### EnhancedDataGrid.tsx

```typescript
// Lines 391-423: GridFormWrapper component that could be simplified
const GridFormWrapper = ({ children }: { children: React.ReactNode }) => {
  const {
    saveChanges,
    cancelChanges,
    addRow,
    hasValidationErrors,
    isRowEditing,
    isRowDirty
  } = useGridForm();

  // Debug: Log selection model
  console.log('EnhancedDataGrid - selectionModel:', selectionModel);

  return (
    <GridModeProvider
      totalRows={totalRows}
      initialMode="none"
      saveChanges={saveChanges}
      cancelChanges={cancelChanges}
      addRow={addRow}
      hasValidationErrors={hasValidationErrors}
      isRowEditing={isRowEditing}
      isRowDirty={isRowDirty}
      canEditRows={canEditRows}
      canAddRows={canAddRows}
      canSelectRows={canSelectRows}
      selectionModel={selectionModel}
      onSelectionModelChange={handleSelectionModelChange}
    >
      {children}
    </GridModeProvider>
  );
};
```

This wrapper component adds unnecessary nesting and could be simplified by moving its logic directly into the parent component.

### GridFormContext.tsx

```typescript
// Lines 297-298: Debug logging that's not needed in production
useEffect(() => {
  console.log('Pending changes:', Array.from(pendingChanges.entries()).map(([rowId, changes]) => ({
    rowId,
    changes
  })));
}, [pendingChanges]);
```

This effect only logs pending changes and doesn't affect component behavior. It should be removed in production code.

## 4. Commented-Out Code

### DataGridToolbar.tsx

```typescript
// Lines 83-91: Commented-out refresh button
{/* <Tooltip title="Refresh">
  <IconButton onClick={onRefresh}>  
    <RefreshIcon />
    Alternative icons:
    <SyncIcon />
    <CachedIcon /> 
  </IconButton>
</Tooltip> */}
```

This commented-out code block for a refresh button should either be implemented or removed entirely.

### UnifiedDataGridToolbar.tsx

```typescript
// Lines 317-318: Commented-out section reference
{/* Middle Section - Pagination removed in favor of built-in DataGrid pagination */}
<Box sx={{ flex: 1 }} />
```

This comment indicates that pagination was moved to the built-in DataGrid component, but the comment and empty Box could be removed or clarified.

## 5. Redundant Code

### Duplicate Context Logic

The `GridModeContext.tsx` and `ToolbarModeContext.tsx` files contain nearly identical code with slight variations. This redundancy should be eliminated by consolidating them into a single context.

```typescript
// GridModeContext.tsx and ToolbarModeContext.tsx both define:
export type GridMode = 'none' | 'edit' | 'add' | 'select';

interface GridModeContextType {
  // Mode state
  mode: GridMode;
  setMode: (newMode: GridMode) => void;
  
  // Selection state
  selectedRowCount: number;
  clearSelection: () => void;
  
  // ... more duplicate code
}
```

### Duplicate Validation Logic

The validation logic is duplicated in multiple places:

1. In `GridFormContext.tsx` within the `setValue` method:

```typescript
// Check if required
if (validation?.required && (value === undefined || value === null || value === '')) {
  const message = typeof validation.required === 'string'
    ? validation.required
    : 'This field is required';
  formState.errors[name] = { type: 'required', message };
}
```

2. And again in the `trigger` method:

```typescript
// Check if required
if (validation.required && (value === undefined || value === null || value === '')) {
  const message = typeof validation.required === 'string'
    ? validation.required
    : 'This field is required';
  formState.errors[field] = { type: 'required', message };
}
```

This validation logic should be extracted into a separate function to avoid duplication.

## Recommendations

1. **Remove Unused Variables**: Delete or comment out variables that are defined but never used.

2. **Clean Up Imports**: Remove unused imports to improve code readability and potentially reduce bundle size.

3. **Eliminate Dead Code**: Remove code blocks that don't contribute to the functionality of the application.

4. **Address Commented-Out Code**: Either implement or remove commented-out code blocks.

5. **Consolidate Redundant Code**: Extract duplicate logic into shared functions or components.

6. **Add TODO Comments**: If certain functionality is planned for the future, add clear TODO comments instead of leaving placeholder code.

## Example Cleanup

### EnhancedDataGridDemo.tsx

```typescript
// Before
import React, { useState } from 'react';
import { Box, Typography, FormControlLabel, Switch, Chip } from '@mui/material';
import { EnhancedDataGrid } from './DataGrid';
import { DataGridToolbar } from './DataGridToolbar';
import { employees, departments } from './data/mockData';

export default function EnhancedDataGridDemo() {
  // State for server-side mode and selection
  const [serverSide, setServerSide] = useState(true);
  const [selectionModel, setSelectionModel] = useState<any[]>([]);
  
  // ... rest of component
  
  // Handle toolbar actions
  const handleSave = (changes: { edits: any[], additions: any[] }) => {
    console.log('Saving changes:', changes);
    // Send to API, etc.
  };
  
  const handleFilter = () => {
    console.log('Filter clicked');
  };
  
  const handleRefresh = () => {
    console.log('Refresh clicked');
  };
  
  const handleExport = () => {
    console.log('Export clicked');
  };
  
  const handleUpload = () => {
    console.log('Upload clicked');
  };
  
  const handleHelp = () => {
    console.log('Help clicked');
  };
  
  // ... rest of component
}

// After
import React, { useState } from 'react';
import { Box, Typography } from '@mui/material';
import { EnhancedDataGrid } from './DataGrid';
import { employees, departments } from './data/mockData';

export default function EnhancedDataGridDemo() {
  // State for selection
  const [selectionModel, setSelectionModel] = useState<any[]>([]);
  
  // ... rest of component
  
  // Handle save changes
  const handleSave = (changes: { edits: any[], additions: any[] }) => {
    console.log('Saving changes:', changes);
    // Send to API, etc.
  };
  
  // ... rest of component
}
```

### GridModeContext.tsx

```typescript
// Before
export const GridModeProvider: React.FC<GridModeProviderProps> = ({
  children,
  totalRows,
  initialMode = 'none',
  // Form state and actions
  saveChanges: formSaveChanges,
  cancelChanges: formCancelChanges,
  addRow: formAddRow,
  hasValidationErrors,
  isRowEditing = () => false,
  isRowDirty = () => false,
  // Grid capabilities
  canEditRows = true,
  canAddRows = true,
  canSelectRows = true,
  // Selection model
  selectionModel: externalSelectionModel,
  onSelectionModelChange: externalOnSelectionModelChange
}) => {
  // ... component implementation
}

// After
export const GridModeProvider: React.FC<GridModeProviderProps> = ({
  children,
  totalRows,
  initialMode = 'none',
  // Form state and actions
  saveChanges: formSaveChanges,
  cancelChanges: formCancelChanges,
  addRow: formAddRow,
  hasValidationErrors,
  isRowEditing = () => false,
  isRowDirty = () => false,
  // Selection model
  selectionModel: externalSelectionModel,
  onSelectionModelChange: externalOnSelectionModelChange
}) => {
  // ... component implementation
}
```

## Conclusion

Cleaning up unused code is an important step in maintaining a healthy codebase. By removing unused variables, imports, and code blocks, you can improve code readability, reduce bundle size, and make the codebase more maintainable and AI-friendly.

The recommendations in this document should be implemented as part of a broader refactoring effort to improve the overall quality of the codebase.


====== docs/codebase-analysis.md ======
Last Modified: 4/11/2025, 06:19 | Size: 11.3 KB | Lines: 354

# React DataGrid Codebase Analysis

## Overview

This document provides a comprehensive analysis of the React DataGrid codebase, identifying dead files, documenting data flow, highlighting areas of high complexity, and recommending refactors to improve maintainability and make the code more AI-friendly.

## 1. Dead/Unused Files

### Confirmed Dead Files

These files are not being used and can be safely removed:

1. **`components/DataGrid/context/GridEditingContext.tsx`**
   - Unused context provider
   - Not exported from context/index.ts
   - No components are using this context

2. **`components/DataGrid/hooks/useGridEditing.ts`**
   - Imports from GridEditingContext but not used anywhere
   - Exported from hooks/index.ts but no components are importing it

3. **`components/DataGridDemo.tsx`**
   - Superseded by EnhancedDataGridDemo.tsx
   - Not imported or used anywhere in the application

### Likely Dead Files

These files appear to be unused or superseded by newer implementations:

1. **`components/UnifiedToolbarDataGridDemo.tsx`**
   - Appears to be a demonstration component that's not actively used
   - The main application uses EnhancedDataGridDemo.tsx instead
   - Only referenced in pages/unified-toolbar.tsx which isn't the main entry point

2. **`components/DataGridToolbar.tsx`**
   - Simple toolbar implementation that has been replaced by UnifiedDataGridToolbar
   - Contains commented-out code and alternative icon options
   - Lacks the modal functionality present in UnifiedDataGridToolbar

### Files Needing Implementation or Removal

1. **`components/DataGrid/components/AddRowButton.tsx`**
   - Has functionality commented out with "add row feature deferred"
   - Should either be fully implemented or removed from the UI

### Unused Variables and Imports

Several components contain unused variables or imports that should be cleaned up:

1. In **`EnhancedDataGridDemo.tsx`**:
   - Imports `Box`, `Typography`, `FormControlLabel`, `Switch`, `Chip` but some aren't used
   - Defines handlers like `handleFilter`, `handleRefresh`, etc. that aren't connected to UI

2. In **`components/DataGrid/EnhancedDataGrid.tsx`**:
   - Several props are defined but not used in some code paths

## 2. Data Flow Documentation

### Main Data Flow

The application follows a complex but structured data flow pattern:

```mermaid
graph TD
    A[User Interaction] --> B[GridModeContext]
    B --> C[GridFormContext]
    C --> D[Form State]
    D --> E[Cell Rendering]
    D --> F[Validation]
    D --> G[Save Changes]
    
    H[Server Data] --> I[useServerSideData]
    I --> J[EnhancedDataGrid]
    
    K[Selection] --> L[useSelectionModel]
    L --> M[GridModeContext]
```

### Key Data Flows

#### Editing Flow

1. **Initialization**:
   - EnhancedDataGrid initializes with columns and rows
   - GridFormProvider creates form state for each row when editing begins
   - Each row gets its own form instance with validation rules

2. **Cell Editing**:
   - User double-clicks a cell → Grid enters edit mode
   - `startEditingCell` is called → Creates form instance if needed
   - Cell value changes → `updateCellValue` → Form state updates
   - Validation runs automatically → Errors stored in form state

3. **Saving Changes**:
   - User clicks Save → `saveChanges` in GridFormContext called
   - Changes collected from form state → Grouped into edits and additions
   - `onSave` callback called with changes → Parent component handles API calls
   - Grid returns to view mode

#### Selection Flow

1. **Selection Changes**:
   - User clicks checkbox → `onSelectionModelChange` called
   - Selection model updates → GridModeContext updates
   - UI reflects selection (toolbar shows count, etc.)

2. **Mode Interaction**:
   - Selection mode conflicts with edit/add modes
   - Confirmation dialog shown when switching modes with selection

#### Server-side Data Flow

1. **Initial Load**:
   - Grid initializes → `useServerSideData` hook called if dataUrl provided
   - Initial data fetched → Grid displays data

2. **Pagination/Sorting/Filtering**:
   - User changes page/sort/filter → Respective handlers called
   - New parameters sent to server → New data fetched
   - Grid updates with new data

## 3. Areas of High Complexity

### 1. Form State Management (`GridFormContext.tsx`)

This component has high complexity due to:

- **Multiple Form Instances**: Manages separate form state for each row being edited
- **Custom Validation**: Implements a complex validation system similar to react-hook-form
- **Change Tracking**: Tracks dirty fields and validates in real-time
- **Original Data Preservation**: Maintains original data to support cancellation
- **Asynchronous Updates**: Uses setTimeout for UI updates after state changes

Key complexity points:
- Lines 80-247: Complex form instance creation with validation logic
- Lines 249-808: GridFormProvider with numerous state variables and refs
- Lines 400-437: Complex dirty state tracking logic
- Lines 531-598: Complex save changes logic with edits/additions separation

### 2. Mode Management (`GridModeContext.tsx` and `ToolbarModeContext.tsx`)

Complexity issues:

- **Duplicate Functionality**: Two similar contexts with overlapping responsibilities
- **Mode Conflicts**: Complex logic to handle conflicts between modes
- **Selection Integration**: Complex integration with selection model
- **State Synchronization**: Needs to keep multiple state sources in sync

Key complexity points:
- Both files implement similar functionality with slight differences
- GridModeContext (lines 62-210): Complex provider with multiple state sources
- ToolbarModeContext (lines 59-169): Similar provider with different implementation details

### 3. Cell Rendering and Editing (`EnhancedDataGrid.tsx`)

Complexity issues:

- **Multiple Rendering Paths**: Different rendering for view/edit modes
- **Event Handling**: Complex event handling for cell clicks, double-clicks, keyboard
- **Component Composition**: Multiple wrapper components and providers
- **Conditional Rendering**: Many conditional rendering paths based on state

Key complexity points:
- Lines 104-464: Large component with many responsibilities
- Lines 207-228: Column transformation with render function wrapping
- Lines 234-389: Complex DataGridWithModeControl component
- Lines 391-423: GridFormWrapper with multiple nested providers

### 4. Deep Prop Drilling and Component Nesting

Complexity issues:

- **Deep Component Hierarchy**: Components nested 5+ levels deep
- **Prop Passing**: Props passed through multiple levels
- **Context Overuse**: Multiple contexts with overlapping responsibilities
- **Wrapper Components**: Many small wrapper components adding to mental overhead

## 4. Recommended Refactors

### 1. Consolidate Context System

- **Merge Mode Contexts**: Combine `GridModeContext` and `ToolbarModeContext` into a single context
- **Clearer Separation of Concerns**: 
  - One context for grid state (selection, pagination)
  - One context for editing state (form state, validation)
  - One context for UI state (toolbar, modals)

### 2. Simplify Component Structure

- **Break Down EnhancedDataGrid**:
  - Extract cell rendering logic to separate components
  - Extract toolbar logic to a separate component
  - Create a clearer component hierarchy

- **Proposed Structure**:
  ```
  DataGrid/
  ├── components/
  │   ├── cells/
  │   │   ├── ViewCell.tsx
  │   │   ├── EditCell.tsx
  │   │   └── CellWrapper.tsx
  │   ├── toolbar/
  │   │   ├── Toolbar.tsx
  │   │   ├── ToolbarActions.tsx
  │   │   └── ToolbarStatus.tsx
  │   └── ...
  ├── contexts/
  │   ├── GridStateContext.tsx
  │   ├── EditingContext.tsx
  │   └── UIContext.tsx
  ├── hooks/
  │   ├── useGridState.ts
  │   ├── useEditing.ts
  │   └── ...
  └── DataGrid.tsx
  ```

### 3. Improve State Management

- **Consider Using a State Management Library**:
  - Redux Toolkit for complex state
  - Zustand for simpler state management
  - React Query for server state

- **Normalize State Structure**:
  - Store rows by ID in a map/object
  - Store selection as a set of IDs
  - Store editing state separately from data

### 4. Standardize Validation

- **Extract Validation Logic**:
  - Move validation out of form state management
  - Create reusable validation functions
  - Consider using a validation library (Zod, Yup)

- **Validation Pipeline**:
  - Field-level validation
  - Row-level validation
  - Cross-field validation

### 5. Improve Type Safety

- **Reduce `any` Types**:
  - Replace `any` with specific types
  - Use generics for reusable components
  - Create type guards for runtime type checking

- **Type Definitions**:
  - Create a comprehensive type system for grid data
  - Define clear interfaces for all components
  - Use discriminated unions for state

## 5. Implementation Plan

### Phase 1: Documentation and Cleanup

1. **Add Inline Comments**:
   - Document complex logic in GridFormContext
   - Document data flow in EnhancedDataGrid
   - Document mode management in GridModeContext

2. **Remove Dead Files**:
   - Remove confirmed dead files
   - Verify and remove likely dead files
   - Clean up unused imports and variables

### Phase 2: Refactoring

1. **Context Consolidation**:
   - Create new context structure
   - Migrate functionality from old contexts
   - Update components to use new contexts

2. **Component Restructuring**:
   - Break down EnhancedDataGrid
   - Create new component hierarchy
   - Update imports and references

### Phase 3: Improvements

1. **State Management**:
   - Implement normalized state structure
   - Improve state update patterns
   - Reduce unnecessary re-renders

2. **Validation System**:
   - Extract validation logic
   - Create reusable validation functions
   - Implement validation pipeline

3. **Type Safety**:
   - Add specific types
   - Replace `any` types
   - Add type guards

## 6. Specific Code Improvements

### EnhancedDataGridDemo.tsx

```typescript
// Current issues:
// - Unused imports
// - Handlers defined but not connected to UI
// - Unclear data flow

// Recommended changes:
// - Remove unused imports
// - Document the purpose of each handler
// - Add comments explaining the data flow
// - Consider moving handlers to a custom hook
```

### GridFormContext.tsx

```typescript
// Current issues:
// - Very large file (800+ lines)
// - Complex state management
// - Multiple responsibilities

// Recommended changes:
// - Split into multiple files
// - Extract form instance creation to separate file
// - Extract validation logic to separate file
// - Add comments explaining the data flow
```

### EnhancedDataGrid.tsx

```typescript
// Current issues:
// - Very large component
// - Multiple nested components
// - Complex rendering logic

// Recommended changes:
// - Extract nested components to separate files
// - Add comments explaining the rendering flow
// - Simplify props passing
```

## Conclusion

The React DataGrid codebase is well-structured but has grown complex over time. By implementing the recommendations in this document, the codebase can become more maintainable, easier to understand, and more AI-friendly. The key focus areas should be:

1. Removing dead code
2. Documenting complex logic
3. Simplifying the component hierarchy
4. Improving state management
5. Enhancing type safety

These improvements will make the codebase more maintainable and easier to extend in the future.


====== docs/data-flow-documentation.md ======
Last Modified: 4/11/2025, 06:19 | Size: 10.3 KB | Lines: 335

# Data Flow Documentation for React DataGrid

This document provides a detailed explanation of how data flows through the React DataGrid components, focusing on the key paths and state transformations.

## Overview

The React DataGrid application has several key data flows:

1. **Grid Data Flow**: How row data is loaded, displayed, and updated
2. **Editing Flow**: How cell editing works from user interaction to state updates
3. **Selection Flow**: How row selection is managed
4. **Validation Flow**: How data validation works
5. **Server-side Data Flow**: How data is fetched from the server

## 1. Grid Data Flow

```mermaid
graph TD
    A[Props: rows, columns] --> B[EnhancedDataGrid]
    B --> C[GridFormProvider]
    C --> D[GridModeProvider]
    D --> E[DataGrid]
    
    F[User Interaction] --> G[Cell Click/Edit]
    G --> H[Form State Update]
    H --> I[Grid Re-render]
    
    J[Save Button Click] --> K[Collect Changes]
    K --> L[onSave Callback]
    L --> M[API/State Update]
    M --> N[Grid Data Update]
```

### Detailed Steps:

1. **Initialization**:
   - `EnhancedDataGridDemo` provides initial `rows` and `columns` data
   - `EnhancedDataGrid` receives this data and sets up the grid
   - Data is passed to MUI X DataGrid for rendering

2. **Data Display**:
   - Each row is rendered using the column definitions
   - Custom cell renderers handle different data types
   - View mode shows formatted data

3. **Data Updates**:
   - When changes are saved, they're collected from form state
   - Changes are passed to the parent via `onSave` callback
   - Parent component is responsible for API calls or state updates
   - Grid is updated with new data when props change

## 2. Editing Flow

```mermaid
graph TD
    A[Double-click Cell] --> B[startEditingCell]
    B --> C[Create Form Instance]
    C --> D[Enter Edit Mode]
    
    E[Edit Cell Value] --> F[updateCellValue]
    F --> G[Form State Update]
    G --> H[Validation]
    
    I[Save Button] --> J[saveChanges]
    J --> K[Collect Edits]
    K --> L[onSave Callback]
    
    M[Cancel Button] --> N[cancelChanges]
    N --> O[Revert to Original]
```

### Detailed Steps:

1. **Starting Edit Mode**:
   - User double-clicks a cell
   - `startEditingCell` is called in `GridFormContext`
   - If row isn't being edited, `startEditingRow` creates a form instance
   - Cell enters edit mode and shows edit component

2. **Editing Values**:
   - User changes cell value
   - `updateCellValue` is called
   - Form state is updated with new value
   - Validation runs if configured
   - UI updates to show validation state

3. **Saving Changes**:
   - User clicks Save button
   - `saveChanges` collects all changes from form state
   - Changes are grouped into edits (existing rows) and additions (new rows)
   - `onSave` callback is called with changes
   - Grid returns to view mode

4. **Canceling Changes**:
   - User clicks Cancel button
   - `cancelChanges` reverts all changes
   - Original data is restored from `originalDataRef`
   - Grid returns to view mode

## 3. Selection Flow

```mermaid
graph TD
    A[Click Row Checkbox] --> B[onSelectionModelChange]
    B --> C[Update Selection Model]
    C --> D[GridModeContext Update]
    D --> E[UI Updates]
    
    F[Clear Selection] --> G[Empty Selection Model]
    G --> H[UI Updates]
    
    I[Mode Change] --> J[Check Selection]
    J --> K{Multiple Selected?}
    K -->|Yes| L[Show Confirmation]
    K -->|No| M[Change Mode]
    L --> N[User Confirms]
    N --> O[Clear Selection]
    O --> P[Change Mode]
```

### Detailed Steps:

1. **Selecting Rows**:
   - User clicks row checkbox
   - `onSelectionModelChange` is called
   - Selection model is updated in `useSelectionModel` hook
   - `GridModeContext` reflects selection count
   - Toolbar updates to show selection count

2. **Mode Interaction**:
   - When user tries to change mode with multiple rows selected
   - Confirmation dialog is shown
   - If confirmed, selection is cleared and mode changes
   - If canceled, selection remains and mode doesn't change

3. **Selection Restrictions**:
   - Selection is disabled in edit and add modes
   - When returning to select mode, previous selection is lost

## 4. Validation Flow

```mermaid
graph TD
    A[Cell Value Change] --> B[setValue in FormMethods]
    B --> C[Run Field Validation]
    C --> D[Update Form State]
    
    E[Save Attempt] --> F[validateRow]
    F --> G[Field-level Validation]
    G --> H[Row-level Validation]
    H --> I{Valid?}
    I -->|Yes| J[Save Changes]
    I -->|No| K[Show Validation Errors]
    
    L[Validation Error] --> M[Update UI]
    M --> N[Show Error Indicators]
```

### Detailed Steps:

1. **Field Validation**:
   - When cell value changes, `setValue` is called
   - Validation rules from column definition are applied
   - Validation results are stored in form state
   - UI updates to show validation state

2. **Row Validation**:
   - When saving, `validateRow` is called for each edited row
   - First, all field validations are run
   - Then, row-level validation function is called if provided
   - Results are combined and stored in form state

3. **Validation UI**:
   - `ValidationIndicator` component shows validation state
   - Invalid fields are highlighted with red border
   - Tooltips show validation error messages
   - Save button is disabled if there are validation errors

## 5. Server-side Data Flow

```mermaid
graph TD
    A[Grid Initialization] --> B{dataUrl Provided?}
    B -->|Yes| C[useServerSideData]
    B -->|No| D[Use Client Data]
    
    C --> E[Fetch Initial Data]
    E --> F[Update Grid]
    
    G[Page Change] --> H[setPage]
    H --> I[Fetch New Page]
    I --> J[Update Grid]
    
    K[Sort Change] --> L[setSortModel]
    L --> M[Fetch Sorted Data]
    M --> N[Update Grid]
    
    O[Filter Change] --> P[setFilterModel]
    P --> Q[Fetch Filtered Data]
    Q --> R[Update Grid]
```

### Detailed Steps:

1. **Initial Data Load**:
   - If `dataUrl` is provided, `useServerSideData` hook is used
   - Initial data is fetched from server
   - Grid displays server data

2. **Pagination**:
   - User changes page
   - `setPage` is called in `useServerSideData`
   - New data is fetched with updated page parameter
   - Grid updates with new data

3. **Sorting and Filtering**:
   - User changes sort or filter
   - Respective handlers update sort/filter models
   - New data is fetched with updated parameters
   - Grid updates with new data

## Grid Capabilities Flow

```mermaid
graph TD
    A[EnhancedDataGridDemo] -->|canAddRows, canEditRows, canSelectRows| B[EnhancedDataGrid]
    B -->|Pass to GridModeProvider| C[GridModeProvider]
    C -->|Store capabilities| D[GridModeContext]
    B -->|Pass to UnifiedDataGridToolbar| E[UnifiedDataGridToolbar]
    E -->|Read from context & props| F[Render UI Controls]
    
    G[canAddRows=false] -->|Hide Add button| H[Toolbar UI]
    I[canEditRows=false] -->|Disable editing| J[Cell interactions]
    K[canSelectRows=false] -->|Hide checkboxes| L[Row selection]
```

### Detailed Steps:

1. **Capability Configuration**:
   - `EnhancedDataGridDemo` sets capability flags like `canAddRows={false}`
   - These flags control which features are available to users
   - Default values in `EnhancedDataGrid` are overridden by explicit props

2. **Toolbar Button Visibility**:
   - `canAddRows` controls whether the Add button appears in the toolbar
   - When `false`, the Add button is completely hidden (not just disabled)
   - This is implemented with conditional rendering: `{canAddRows && (...)}`

3. **Edit Capability**:
   - `canEditRows` controls whether cells can be edited
   - When `false`, double-clicking cells doesn't enter edit mode
   - Edit mode is disabled for all cells

4. **Selection Capability**:
   - `canSelectRows` controls whether row selection is enabled
   - When `false`, checkboxes are hidden and rows can't be selected
   - Selection-related UI elements are hidden

## Component Interaction

The following diagram shows how the different components interact with each other:

```mermaid
graph TD
    A[EnhancedDataGridDemo] --> B[EnhancedDataGrid]
    B --> C[GridFormProvider]
    C --> D[GridFormWithToolbar]
    D --> E[GridFormWrapper]
    E --> F[GridModeProvider]
    F --> G[UnifiedDataGridToolbar]
    F --> H[DataGridWithModeControl]
    H --> I[DataGrid]
    
    J[useGridForm] --> C
    K[useGridMode] --> F
    L[useSelectionModel] --> F
    M[usePagination] --> F
    N[useServerSideData] --> B
    O[useGridNavigation] --> B
```

## State Management

The application uses a combination of React context and hooks for state management:

1. **GridFormContext**: Manages form state for editing
   - Form instances for each row
   - Validation state
   - Dirty state tracking
   - Original data preservation

2. **GridModeContext**: Manages grid mode
   - Current mode (none, edit, add, select)
   - Selection state
   - Editing state
   - Action handlers

3. **Custom Hooks**:
   - `useSelectionModel`: Manages row selection
   - `usePagination`: Manages pagination state
   - `useServerSideData`: Manages server data fetching
   - `useGridNavigation`: Manages keyboard navigation

## Data Transformation

Data undergoes several transformations as it flows through the application:

1. **Input Data** → **Grid Data**:
   - Column definitions are enhanced with field configs
   - Rows are prepared for display

2. **Grid Data** → **Form Data**:
   - When editing starts, grid data is copied to form state
   - Original data is preserved for cancellation

3. **Form Data** → **Validated Data**:
   - Form data is validated according to rules
   - Validation errors are tracked

4. **Form Data** → **Output Data**:
   - When saving, form data is collected
   - Changes are extracted by comparing with original data
   - Output is formatted as edits and additions

## Conclusion

The data flow in the React DataGrid application is complex but well-structured. Understanding these flows is essential for maintaining and extending the application. The key points to remember are:

1. Data flows from props to grid to form state and back
2. Editing is managed through a custom form state system
3. Validation happens at both field and row levels
4. Selection and editing modes have complex interactions
5. Server-side data is managed through dedicated hooks

By following these data flows, you can understand how changes in one part of the application affect other parts, making it easier to debug issues and implement new features.


====== docs/implementation-roadmap.md ======
Last Modified: 4/11/2025, 06:19 | Size: 6.2 KB | Lines: 175

# Implementation Roadmap

This document provides a step-by-step roadmap for implementing the recommendations from the analysis documents. It outlines a clear path forward to make your React DataGrid codebase more maintainable and AI-friendly.

## Overview of Documentation

We've created several documents to help you understand and improve your codebase:

1. **[Codebase Analysis](./codebase-analysis.md)**: A comprehensive analysis of the codebase, identifying dead files, documenting data flow, highlighting areas of high complexity, and recommending refactors.

2. **[Data Flow Documentation](./data-flow-documentation.md)**: Detailed explanation of how data flows through your application, with diagrams and step-by-step descriptions.

3. **[Refactoring Guide](./refactoring-guide.md)**: Specific code examples and step-by-step instructions for implementing the recommended refactors.

4. **[Unused Code Analysis](./unused-code-analysis.md)**: Identification of unused variables, imports, and code blocks that can be safely removed.

## Implementation Phases

We recommend implementing the changes in the following phases:

### Phase 1: Documentation and Cleanup (1-2 days)

1. **Add Inline Comments**
   - Add documentation to complex logic in GridFormContext.tsx
   - Add documentation to event handlers in EnhancedDataGrid.tsx
   - Add documentation to useEffect hooks in GridModeContext.tsx

2. **Remove Dead Files**
   - Remove components/DataGrid/context/GridEditingContext.tsx
   - Remove components/DataGrid/hooks/useGridEditing.ts
   - Remove components/DataGridDemo.tsx
   - Verify and remove components/UnifiedToolbarDataGridDemo.tsx
   - Update imports and references accordingly

3. **Clean Up Unused Code**
   - Remove unused variables identified in [Unused Code Analysis](./unused-code-analysis.md)
   - Remove unused imports
   - Remove dead code blocks
   - Remove commented-out code
   - Remove debug console.log statements

### Phase 2: Context System Consolidation (2-3 days)

1. **Create New Context Structure**
   - Create GridStateContext.tsx for grid state management
   - Create EditingContext.tsx for form state management
   - Create UIContext.tsx for UI state management

2. **Migrate Functionality**
   - Move functionality from GridModeContext to appropriate new contexts
   - Move functionality from ToolbarModeContext to appropriate new contexts
   - Update components to use new contexts

3. **Remove Old Contexts**
   - Remove GridModeContext.tsx
   - Remove ToolbarModeContext.tsx
   - Update imports and references

### Phase 3: Component Restructuring (2-3 days)

1. **Break Down EnhancedDataGrid**
   - Extract cell rendering logic to separate components
   - Extract toolbar logic to separate components
   - Create a clearer component hierarchy

2. **Simplify Component Props**
   - Reduce prop drilling
   - Use context for shared state
   - Create more focused components with fewer props

3. **Improve Component Composition**
   - Use composition over inheritance
   - Create reusable components
   - Implement render props pattern where appropriate

### Phase 4: State Management Improvements (2-3 days)

1. **Normalize State Structure**
   - Store rows by ID in a map/object
   - Store selection as a set of IDs
   - Store editing state separately from data

2. **Extract Validation Logic**
   - Create a validation system
   - Move validation logic out of form state management
   - Implement field-level and row-level validation

3. **Improve State Updates**
   - Reduce unnecessary re-renders
   - Implement more efficient state updates
   - Use memoization where appropriate

### Phase 5: Type Safety Enhancements (1-2 days)

1. **Improve Type Definitions**
   - Create comprehensive type system for grid data
   - Define clear interfaces for all components
   - Use discriminated unions for state

2. **Reduce `any` Types**
   - Replace `any` with specific types
   - Use generics for reusable components
   - Create type guards for runtime type checking

3. **Add Type Documentation**
   - Document complex types
   - Add JSDoc comments to type definitions
   - Improve type inference

## Testing Strategy

After each phase, we recommend testing the application to ensure that functionality is preserved. Here's a testing strategy:

1. **Manual Testing**
   - Test cell editing functionality
   - Test validation rules
   - Test row-level validation
   - Test saving changes
   - Test canceling changes
   - Test selection functionality
   - Test pagination

2. **Unit Testing**
   - Add unit tests for validation logic
   - Add unit tests for state management
   - Add unit tests for complex transformations

3. **Integration Testing**
   - Test the interaction between components
   - Test the data flow through the application
   - Test edge cases and error handling

## Estimated Timeline

| Phase | Description | Estimated Time |
|-------|-------------|----------------|
| 1 | Documentation and Cleanup | 1-2 days |
| 2 | Context System Consolidation | 2-3 days |
| 3 | Component Restructuring | 2-3 days |
| 4 | State Management Improvements | 2-3 days |
| 5 | Type Safety Enhancements | 1-2 days |
| | **Total** | **8-13 days** |

## Prioritization

If you need to prioritize the work, we recommend the following order:

1. **High Priority**
   - Remove dead files and unused code
   - Add inline comments to complex logic
   - Consolidate context system

2. **Medium Priority**
   - Break down EnhancedDataGrid
   - Normalize state structure
   - Extract validation logic

3. **Lower Priority**
   - Improve type safety
   - Optimize performance
   - Add comprehensive tests

## Next Steps

1. Review the documentation and roadmap
2. Decide on the implementation approach
3. Begin with Phase 1: Documentation and Cleanup
4. Proceed through the phases at your own pace
5. Test after each phase to ensure functionality is preserved

## Conclusion

By following this roadmap, you'll transform your React DataGrid codebase into a more maintainable, understandable, and AI-friendly application. The changes are designed to be implemented incrementally, allowing you to make progress without disrupting the existing functionality.

If you have any questions or need further clarification, please refer to the detailed documentation or reach out for assistance.


====== docs/refactoring-guide.md ======
Last Modified: 4/11/2025, 06:19 | Size: 18.2 KB | Lines: 687

# React DataGrid Refactoring Guide

This document provides detailed guidance on how to refactor the React DataGrid codebase to improve maintainability and make it more AI-friendly. It includes specific code examples and step-by-step instructions.

## Table of Contents

1. [Adding Inline Comments](#1-adding-inline-comments)
2. [Removing Dead Files](#2-removing-dead-files)
3. [Consolidating Context System](#3-consolidating-context-system)
4. [Simplifying Component Structure](#4-simplifying-component-structure)
5. [Improving State Management](#5-improving-state-management)
6. [Standardizing Validation](#6-standardizing-validation)
7. [Enhancing Type Safety](#7-enhancing-type-safety)

## 1. Adding Inline Comments

### Key Areas for Documentation

#### GridFormContext.tsx

```typescript
// Before
const createFormInstance = (defaultValues: Record<string, any>, columns: EnhancedColumnConfig[]): FormMethods => {
  try {
    const formState: FormState = {
      values: { ...defaultValues },
      errors: {},
      dirtyFields: {},
      isDirty: false,
      isValid: true,
    };
    
    // ... rest of the function
  } catch (error) {
    console.error('Error creating form instance:', error);
    throw new Error('Failed to create form instance');
  }
};

// After
/**
 * Creates a form instance for a specific row with validation capabilities
 * 
 * This factory function creates a self-contained form state manager that:
 * 1. Maintains values, errors, and dirty state for a row
 * 2. Provides methods to get/set values and manage validation
 * 3. Tracks which fields have been modified from their original values
 * 
 * @param defaultValues - The initial values for the form (from the row data)
 * @param columns - Column definitions containing validation rules
 * @returns A FormMethods object with state and methods to manage the form
 */
const createFormInstance = (defaultValues: Record<string, any>, columns: EnhancedColumnConfig[]): FormMethods => {
  try {
    // Initialize form state with default values and empty tracking objects
    const formState: FormState = {
      values: { ...defaultValues }, // Copy to avoid mutating the original
      errors: {}, // No validation errors initially
      dirtyFields: {}, // No modified fields initially
      isDirty: false, // Form starts in pristine state
      isValid: true, // Form starts as valid until proven otherwise
    };
    
    // ... rest of the function
  } catch (error) {
    console.error('Error creating form instance:', error);
    throw new Error('Failed to create form instance');
  }
};
```

#### EnhancedDataGrid.tsx

```typescript
// Before
const handleCellClick = (params: any) => {
  if (mode === 'edit') {
    if (params.field === '__check__' || params.field === '__actions__') {
      return;
    }
    
    const { id, field } = params;
    const column = columns.find(col => col.field === field);
    
    if (column?.editable !== false && canEditRows) {
      try {
        const cellMode = apiRef.current.getCellMode(id, field);
        if (cellMode === 'view') {
          apiRef.current.startCellEditMode({ id, field });
        }
      } catch (error) {
        console.error('Error starting cell edit mode:', error);
      }
    }
  }
};

// After
/**
 * Handles cell click events based on the current grid mode
 * 
 * In edit mode:
 * - Allows single click to edit cells (for better UX when already editing)
 * - Ignores clicks on checkboxes and action columns
 * - Only edits cells that are marked as editable
 * 
 * In other modes:
 * - Single click does nothing (double click is used to enter edit mode)
 * 
 * @param params - Cell parameters from MUI X DataGrid
 */
const handleCellClick = (params: any) => {
  // Only process clicks when in edit mode
  if (mode === 'edit') {
    // Ignore clicks on special columns
    if (params.field === '__check__' || params.field === '__actions__') {
      return;
    }
    
    const { id, field } = params;
    const column = columns.find(col => col.field === field);
    
    // Only allow editing if the column is editable and editing is enabled globally
    if (column?.editable !== false && canEditRows) {
      try {
        // Check current cell mode and start edit mode if in view mode
        const cellMode = apiRef.current.getCellMode(id, field);
        if (cellMode === 'view') {
          apiRef.current.startCellEditMode({ id, field });
        }
      } catch (error) {
        console.error('Error starting cell edit mode:', error);
      }
    }
  }
  // In other modes, single click does nothing - we'll use double click for initial editing
};
```

#### GridModeContext.tsx

```typescript
// Before
// Update editing rows when form state changes
useEffect(() => {
  const newEditingRows = new Set<GridRowId>();
  
  if (isRowDirty) {
    selectionModel.forEach((rowId: GridRowId) => {
      if (isRowEditing(rowId) && isRowDirty(rowId)) {
        newEditingRows.add(rowId);
      }
    });
  } else {
    selectionModel.forEach((rowId: GridRowId) => {
      if (isRowEditing(rowId)) {
        newEditingRows.add(rowId);
      }
    });
  }
  
  setEditingRows(newEditingRows);
}, [selectionModel, isRowEditing, isRowDirty]);

// After
/**
 * Effect to track which rows are being edited with actual changes
 * 
 * This effect:
 * 1. Monitors the selection model and row editing/dirty state
 * 2. Creates a set of rows that are both being edited AND have actual changes
 * 3. Updates the editingRows state which affects UI and save behavior
 * 
 * Two approaches are used:
 * - If isRowDirty is available: Only count rows with actual field changes
 * - Otherwise: Count all rows being edited regardless of changes
 * 
 * This ensures we only track rows that need to be saved.
 */
useEffect(() => {
  // Create a new set to track rows with changes
  const newEditingRows = new Set<GridRowId>();
  
  // If we can check for dirty state (actual field changes)
  if (isRowDirty) {
    // Only count rows that are both being edited AND have actual changes
    selectionModel.forEach((rowId: GridRowId) => {
      if (isRowEditing(rowId) && isRowDirty(rowId)) {
        newEditingRows.add(rowId);
      }
    });
  } else {
    // Fallback: count all rows being edited
    selectionModel.forEach((rowId: GridRowId) => {
      if (isRowEditing(rowId)) {
        newEditingRows.add(rowId);
      }
    });
  }
  
  // Update the state with the new set of editing rows
  setEditingRows(newEditingRows);
}, [selectionModel, isRowEditing, isRowDirty]);
```

## 2. Removing Dead Files

### Files to Remove

1. **`components/DataGrid/context/GridEditingContext.tsx`**
2. **`components/DataGrid/hooks/useGridEditing.ts`**
3. **`components/DataGridDemo.tsx`**
4. **`components/UnifiedToolbarDataGridDemo.tsx`** (after verifying it's not used)

### Update References

After removing files, update any references:

```typescript
// In components/DataGrid/context/index.ts
// Before
export * from './GridFormContext';
export * from './GridModeContext';
export * from './ToolbarModeContext';
export * from './GridEditingContext'; // Remove this line

// After
export * from './GridFormContext';
export * from './GridModeContext';
export * from './ToolbarModeContext';
// GridEditingContext export removed
```

```typescript
// In components/DataGrid/hooks/index.ts
// Before
export * from './useGridNavigation';
export * from './useGridValidation';
export * from './usePagination';
export * from './useSelectionModel';
export * from './useServerSideData';
export * from './useGridEditing'; // Remove this line

// After
export * from './useGridNavigation';
export * from './useGridValidation';
export * from './usePagination';
export * from './useSelectionModel';
export * from './useServerSideData';
// useGridEditing export removed
```

### Update pages/unified-toolbar.tsx

```typescript
// Before
import React from 'react';
import { UnifiedToolbarDataGridDemo } from '../components/UnifiedToolbarDataGridDemo';

export default function UnifiedToolbarPage() {
  return (
    <div className="container mx-auto">
      <UnifiedToolbarDataGridDemo />
    </div>
  );
}

// After
import React from 'react';
import EnhancedDataGridDemo from '../components/EnhancedDataGridDemo';

export default function UnifiedToolbarPage() {
  return (
    <div className="container mx-auto">
      <EnhancedDataGridDemo />
    </div>
  );
}
```

## 3. Consolidating Context System

### Create a New Context Structure

#### 1. Create GridStateContext.tsx

```typescript
import React, { createContext, useContext, useState, useCallback } from 'react';
import { GridRowId } from '@mui/x-data-grid';

// Define the grid state type
export type GridMode = 'none' | 'edit' | 'add' | 'select';

// Define the context type
interface GridStateContextType {
  // Mode state
  mode: GridMode;
  setMode: (newMode: GridMode) => void;
  
  // Selection state
  selectionModel: GridRowId[];
  onSelectionModelChange: (newModel: GridRowId[]) => void;
  selectedRowCount: number;
  clearSelection: () => void;
  
  // Pagination state
  page: number;
  pageSize: number;
  totalRows: number;
  setPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
  
  // UI state
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
}

// Create the context
const GridStateContext = createContext<GridStateContextType | undefined>(undefined);

// Provider props
interface GridStateProviderProps {
  children: React.ReactNode;
  totalRows: number;
  initialSelectionModel?: GridRowId[];
  onSelectionModelChange?: (selectionModel: GridRowId[]) => void;
}

// Provider component
export const GridStateProvider: React.FC<GridStateProviderProps> = ({
  children,
  totalRows,
  initialSelectionModel = [],
  onSelectionModelChange: externalOnSelectionModelChange
}) => {
  // State for the current mode
  const [mode, setMode] = useState<GridMode>('none');
  
  // State for selection
  const [selectionModel, setSelectionModel] = useState<GridRowId[]>(initialSelectionModel);
  
  // State for pagination
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(25);
  
  // State for UI
  const [isLoading, setIsLoading] = useState(false);
  
  // Handle selection model change
  const handleSelectionModelChange = useCallback((newModel: GridRowId[]) => {
    setSelectionModel(newModel);
    if (externalOnSelectionModelChange) {
      externalOnSelectionModelChange(newModel);
    }
  }, [externalOnSelectionModelChange]);
  
  // Clear selection
  const clearSelection = useCallback(() => {
    handleSelectionModelChange([]);
  }, [handleSelectionModelChange]);
  
  // Derived state
  const selectedRowCount = selectionModel.length;
  
  // Context value
  const contextValue: GridStateContextType = {
    mode,
    setMode,
    selectionModel,
    onSelectionModelChange: handleSelectionModelChange,
    selectedRowCount,
    clearSelection,
    page,
    pageSize,
    totalRows,
    setPage,
    setPageSize,
    isLoading,
    setIsLoading
  };
  
  return (
    <GridStateContext.Provider value={contextValue}>
      {children}
    </GridStateContext.Provider>
  );
};

// Hook to use the context
export const useGridState = () => {
  const context = useContext(GridStateContext);
  if (!context) {
    throw new Error('useGridState must be used within a GridStateProvider');
  }
  return context;
};
```

## 4. Simplifying Component Structure

### Break Down EnhancedDataGrid

#### 1. Extract Cell Components

```tsx
// components/DataGrid/cells/ViewCell.tsx
import React from 'react';
import { GridRenderCellParams } from '@mui/x-data-grid';
import { EnhancedColumnConfig } from '../EnhancedDataGrid';
import { useEditing } from '../contexts/EditingContext';

interface ViewCellProps {
  params: GridRenderCellParams;
  column: EnhancedColumnConfig;
}

export const ViewCell: React.FC<ViewCellProps> = ({ params, column }) => {
  const { isFieldDirty, getRowErrors } = useEditing();
  const isDirty = isFieldDirty(params.id, params.field);
  const errors = getRowErrors(params.id);
  const error = errors?.[params.field];
  
  // Render the cell based on field type
  let content: React.ReactNode;
  
  switch (column.fieldConfig.type) {
    case 'boolean':
      content = params.value ? 'Yes' : 'No';
      break;
    case 'date':
      content = params.value ? new Date(params.value).toLocaleDateString() : '';
      break;
    case 'select':
      const option = column.fieldConfig.options?.find(opt => opt.value === params.value);
      content = option ? option.label : '';
      break;
    default:
      content = params.value;
  }
  
  // Apply validation styling if needed
  if (isDirty) {
    const style: React.CSSProperties = {};
    
    if (error) {
      style.border = '1px solid red';
      style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
    } else {
      style.border = '1px solid green';
      style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
    }
    
    return (
      <div style={style} title={error ? error.message : undefined}>
        {content}
      </div>
    );
  }
  
  return <>{content}</>;
};
```

## 5. Improving State Management

### Normalize State Structure

```typescript
// types/grid.ts
export interface GridRow {
  id: GridRowId;
  [key: string]: any;
}

export interface GridState {
  // Data
  rows: Record<GridRowId, GridRow>;
  originalRows: Record<GridRowId, GridRow>;
  addedRows: GridRowId[];
  
  // UI State
  mode: 'none' | 'edit' | 'add' | 'select';
  selection: GridRowId[];
  editingCell?: { rowId: GridRowId; field: string };
  
  // Pagination
  page: number;
  pageSize: number;
  totalRows: number;
  
  // Validation
  errors: Record<GridRowId, Record<string, { type: string; message: string }>>;
  dirtyFields: Record<GridRowId, Record<string, boolean>>;
}
```

## 6. Standardizing Validation

### Create a Validation System

```typescript
// validation/validators.ts
import { ValidationOptions } from '../types/form';

export interface ValidationResult {
  valid: boolean;
  error?: {
    type: string;
    message: string;
  };
}

export const validateRequired = (value: any, message = 'This field is required'): ValidationResult => {
  const valid = value !== undefined && value !== null && value !== '';
  return {
    valid,
    error: valid ? undefined : { type: 'required', message }
  };
};

export const validatePattern = (value: string, pattern: RegExp, message: string): ValidationResult => {
  const valid = pattern.test(value);
  return {
    valid,
    error: valid ? undefined : { type: 'pattern', message }
  };
};

export const validateMin = (value: number, min: number, message: string): ValidationResult => {
  const valid = value >= min;
  return {
    valid,
    error: valid ? undefined : { type: 'min', message }
  };
};

export const validateMax = (value: number, max: number, message: string): ValidationResult => {
  const valid = value <= max;
  return {
    valid,
    error: valid ? undefined : { type: 'max', message }
  };
};

export const validateField = (value: any, validation?: ValidationOptions): ValidationResult => {
  if (!validation) {
    return { valid: true };
  }
  
  // Required validation
  if (validation.required) {
    const message = typeof validation.required === 'string' 
      ? validation.required 
      : 'This field is required';
    
    const result = validateRequired(value, message);
    if (!result.valid) {
      return result;
    }
  }
  
  // Pattern validation
  if (validation.pattern && typeof value === 'string') {
    const result = validatePattern(value, validation.pattern.value, validation.pattern.message);
    if (!result.valid) {
      return result;
    }
  }
  
  // Min validation
  if (validation.min && typeof value === 'number') {
    const result = validateMin(value, validation.min.value, validation.min.message);
    if (!result.valid) {
      return result;
    }
  }
  
  // Max validation
  if (validation.max && typeof value === 'number') {
    const result = validateMax(value, validation.max.value, validation.max.message);
    if (!result.valid) {
      return result;
    }
  }
  
  // Custom validation
  if (validation.validate && typeof validation.validate === 'function') {
    const customResult = validation.validate(value);
    
    if (typeof customResult === 'string') {
      return {
        valid: false,
        error: { type: 'validate', message: customResult }
      };
    } else if (customResult === false) {
      return {
        valid: false,
        error: { type: 'validate', message: 'Invalid value' }
      };
    }
  }
  
  return { valid: true };
};
```

## 7. Enhancing Type Safety

### Improve Type Definitions

```typescript
// types/grid.ts
import { GridRowId } from '@mui/x-data-grid';
import { ValidationOptions } from './form';

// Grid mode type
export type GridMode = 'none' | 'edit' | 'add' | 'select';

// Field configuration
export interface FieldConfig<T = any> {
  type: 'string' | 'number' | 'date' | 'boolean' | 'select';
  options?: Array<{value: any, label: string}>;
  validation?: ValidationOptions;
  parse?: (value: any) => T | null;
  format?: (value: T | null) => string;
}

// Column configuration
export interface EnhancedColumnConfig<T = any> {
  field: string;
  headerName: string;
  width: number;
  editable?: boolean;
  fieldConfig: FieldConfig<T>;
}

// Row data
export interface GridRow {
  id: GridRowId;
  [key: string]: any;
}

// Changes structure
export interface GridChanges {
  edits: Array<{
    id: GridRowId;
    changes: Record<string, any>;
  }>;
  additions: GridRow[];
}

// Cell location
export interface CellLocation {
  rowId: GridRowId;
  field: string;
}

// Error structure
export interface FieldError {
  type: string;
  message: string;
}

// Form state
export interface FormState {
  values: Record<string, any>;
  errors: Record<string, FieldError>;
  dirtyFields: Record<string, boolean>;
  isDirty: boolean;
  isValid: boolean;
}
```

## Conclusion

This refactoring guide provides a roadmap for improving the React DataGrid codebase. By following these recommendations, you can make the code more maintainable, easier to understand, and more AI-friendly.

The key principles to follow are:
1. Document complex logic with clear comments
2. Break down large components into smaller, focused ones
3. Consolidate and simplify the context system
4. Normalize state structure for easier management
5. Standardize validation for consistency
6. Enhance type safety to catch errors early

Implementing these changes will result in a codebase that is easier to maintain, extend, and understand.



====== docs/select-field-fix-plan.md ======
Last Modified: 3/19/2025, 15:51 | Size: 4.4 KB | Lines: 127

# SelectField Implementation Fix Plan

## Problem Statement

There's an issue with the SelectField implementation in the DataGrid component. When the page loads, the table is showing numbers (keys) instead of the labels for those keys in the Department column.

## Current Implementation Analysis

Looking at the code flow:

1. In `EnhancedDataGridDemo.tsx`, we have a column configuration for the department field:
```typescript
{ 
  field: 'departmentId', 
  headerName: 'Department',
  fieldConfig: {
    type: 'select' as const,
    options: departments.map(dept => ({
      value: dept.id,
      label: dept.label
    }))
  }
}
```

2. In `CellRenderer.tsx`, the rendering logic is:
```typescript
let content: React.ReactNode;
if (column.fieldConfig?.renderViewMode) {
  content = column.fieldConfig.renderViewMode(value, row);
} else if (column.fieldType?.renderViewMode) {
  content = column.fieldType.renderViewMode(value, row);
} else {
  // Default rendering
  content = value != null ? String(value) : '';
}
```

3. In `SelectField.tsx`, we have a class that implements rendering logic:
```typescript
renderViewMode(value: T | null, row: any) {
  if (value === null || value === undefined) return <span></span>;
  
  const option = this.options.find(opt => opt[this.valueKey] === value);
  return <span>{option ? option[this.labelKey] : String(value)}</span>;
}
```

## Root Cause

The issue is that the `SelectFieldType` class is never being instantiated and attached to the column configuration. The `fieldConfig` object in the column definition doesn't have a `renderViewMode` method, and the `fieldType` property isn't being set to an instance of `SelectFieldType`.

As a result, the renderer falls back to the default rendering logic: `content = value != null ? String(value) : ''`, which just converts the numeric department ID to a string.

## Proposed Solutions

### Solution 1: Add a renderViewMode to fieldConfig

Modify the `EnhancedDataGridDemo.tsx` file to include a custom `renderViewMode` method in the `fieldConfig` for the select field:

```typescript
fieldConfig: {
  type: 'select' as const,
  options: departments.map(dept => ({
    value: dept.id,
    label: dept.label
  })),
  renderViewMode: (value: any) => {
    const option = departments.find(dept => dept.id === value);
    return <span>{option ? option.label : String(value)}</span>;
  }
}
```

### Solution 2: Create and attach a SelectFieldType instance

Modify the `EnhancedDataGrid.tsx` file to create and attach a `SelectFieldType` instance to the column configuration for select fields:

```typescript
// In EnhancedDataGrid.tsx, before creating gridColumns
import { SelectFieldType } from './fieldTypes/SelectField';

// Inside the EnhancedDataGrid function, before mapping columns to gridColumns
columns.forEach(column => {
  if (column.fieldConfig?.type === 'select' && !column.fieldType) {
    column.fieldType = new SelectFieldType({
      options: column.fieldConfig.options || [],
      valueKey: 'value',
      labelKey: 'label'
    });
  }
});
```

### Solution 3: Modify the CellRenderer

Modify the `CellRenderer.tsx` file to handle select fields specially:

```typescript
if (column.fieldConfig?.type === 'select' && value != null) {
  const options = column.fieldConfig.options || [];
  const option = options.find(opt => opt.value === value);
  content = option ? option.label : String(value);
} else if (column.fieldConfig?.renderViewMode) {
  content = column.fieldConfig.renderViewMode(value, row);
} else if (column.fieldType?.renderViewMode) {
  content = column.fieldType.renderViewMode(value, row);
} else {
  content = value != null ? String(value) : '';
}
```

## Recommendation

Solution 2 is the most elegant and reusable approach. It leverages the existing `SelectFieldType` class without requiring changes to every select field definition or modifying the core rendering logic.

## Implementation Steps

1. Import the `SelectFieldType` class in `EnhancedDataGrid.tsx`
2. Add code to instantiate the `SelectFieldType` for select fields before mapping columns to gridColumns
3. Test the implementation to ensure that the labels are displayed correctly

## Potential Challenges

- Ensuring that the `SelectFieldType` class is correctly instantiated with the right options
- Handling cases where the options might have different property names than 'value' and 'label'
- Ensuring that the `SelectFieldType` class is only instantiated once per column


====== docs/summary.md ======
Last Modified: 3/19/2025, 14:57 | Size: 3.2 KB | Lines: 75

# DataGrid Architecture Evolution Summary

This document summarizes our analysis and proposed solution for removing the react-hook-form dependency and cleaning up unused code in the DataGrid component.

## Initial Analysis

### React-Hook-Form Dependency

Our analysis revealed that the DataGrid component has a **limited dependency** on react-hook-form:

- It primarily uses react-hook-form for its **type definitions** (RegisterOptions, FieldError, FieldValues, FieldPath)
- It follows react-hook-form's **validation schema format** for column definitions
- It does **not** use react-hook-form's actual hooks or form state management functionality
- Instead, it implements a **custom form management system** in GridFormContext.tsx

### Unused Files

We identified several files that are not being used:

- `components/DataGrid/context/GridEditingContext.tsx`: Unused context provider
- `components/DataGrid/hooks/useGridEditing.ts`: Unused hook
- `components/DataGridDemo.tsx`: Superseded by EnhancedDataGridDemo
- `components/DataGrid/components/AddRowButton.tsx`: Feature deferred (commented out)

## Solution Implemented

We've created a comprehensive solution to address these issues:

1. **Architecture Evolution Roadmap** (`docs/architecture-evolution.md`)
   - Detailed plan for removing the react-hook-form dependency
   - Four-phase approach with clear steps and timelines
   - Design principles for our implementation

2. **Custom Form Types** (`types/form.ts`)
   - Replacement types for react-hook-form's types
   - Maintains familiar API for easy migration
   - Simplified for our specific needs

3. **Refactored Components** (`.refactored.tsx` files)
   - Examples of how to update components to use our custom types
   - Maintains the same functionality and API

4. **Form Validation Documentation** (`docs/form-validation.md`)
   - Explains our approach to form validation
   - Documents the API and validation rules
   - Provides examples for developers

5. **Migration Script** (`scripts/migrate-from-rhf.js`)
   - Helps automate the migration process
   - Scans for react-hook-form imports and suggests replacements

6. **Cleanup List** (`docs/cleanup-list.md`)
   - Lists files to remove or refactor
   - Provides details on why each file is unused
   - Includes testing strategy and effort estimation

## Benefits of This Approach

1. **Reduced Dependencies**: Smaller bundle size and fewer potential conflicts
2. **Simplified Implementation**: Code that's easier to understand and maintain
3. **Tailored Solution**: Form management specifically designed for data grid editing
4. **Familiar API**: Developers familiar with react-hook-form will find our API intuitive
5. **Clean Codebase**: Removing unused files improves maintainability

## Next Steps

1. Review the proposed solution and documentation
2. Implement the changes according to the roadmap
3. Test thoroughly to ensure everything works correctly
4. Update the main README with information about the form validation approach

## Conclusion

Our analysis shows that removing the react-hook-form dependency is feasible and beneficial. The custom implementation we've designed maintains the familiar API while being more tailored to our specific needs. The cleanup of unused files will improve the maintainability of the codebase.



====== docs/cleanup-list.md ======
Last Modified: 3/19/2025, 14:57 | Size: 2.6 KB | Lines: 79

# Cleanup List for DataGrid Refactoring

This document lists the files that should be removed or refactored as part of the process to remove the react-hook-form dependency and clean up unused code.

## Files to Remove

These files are not being used and can be safely removed:

1. `components/DataGrid/context/GridEditingContext.tsx`
   - Unused context provider
   - Not exported from context/index.ts
   - No components are using this context

2. `components/DataGrid/hooks/useGridEditing.ts`
   - Imports from GridEditingContext but not used anywhere
   - Exported from hooks/index.ts but no components are importing it

3. `components/DataGridDemo.tsx`
   - Superseded by EnhancedDataGridDemo.tsx
   - Not imported or used anywhere in the application

## Files to Refactor or Implement

These files need to be refactored or implemented:

1. `components/DataGrid/components/AddRowButton.tsx`
   - Currently has functionality commented out with "add row feature deferred"
   - Either implement the feature or remove the component from the UI

## Files to Refactor to Remove react-hook-form Dependency

These files need to be updated to use our custom types instead of react-hook-form types:

1. `components/DataGrid/EnhancedDataGrid.tsx`
   - Replace RegisterOptions import with ValidationOptions from our custom types

2. `components/DataGrid/context/GridFormContext.tsx`
   - Replace FieldValues, FieldError, RegisterOptions, FieldPath imports
   - Replace SimpleFormState and SimpleFormMethods with our custom FormState and FormMethods

3. `components/DataGrid/components/ValidationIndicator.tsx`
   - Replace FieldError import with our custom FieldError type

4. `components/DataGrid/renderers/CellRenderer.tsx`
   - Replace FieldError import with our custom FieldError type

5. `components/DataGrid/renderers/EditCellRenderer.tsx`
   - Update any react-hook-form types used

## Migration Process

1. Create the custom types in `types/form.ts` (already done)
2. Update imports in all files to use our custom types
3. Refactor the form management implementation in GridFormContext.tsx
4. Remove unused files
5. Remove react-hook-form from package.json
6. Run tests to ensure everything works correctly

## Testing Strategy

After refactoring, we should test:

1. Cell editing functionality
2. Validation rules (required, min, max, pattern)
3. Row-level validation
4. Form state tracking (dirty fields, errors)
5. Visual feedback for validation errors
6. Saving changes
7. Canceling changes

## Estimated Effort

- Creating custom types: 1 day
- Refactoring components: 2-3 days
- Testing and fixing issues: 1-2 days
- Documentation: 1 day

Total: 5-7 days



====== docs/form-validation.md ======
Last Modified: 3/19/2025, 14:56 | Size: 3.8 KB | Lines: 145

# Form Validation in DataGrid

This document explains our approach to form validation in the DataGrid component after removing the react-hook-form dependency.

## Overview

Our DataGrid component provides built-in form validation for cell editing with a familiar API inspired by react-hook-form. The implementation is tailored specifically for data grid editing scenarios, making it more lightweight and focused than a general-purpose form library.

## Validation Schema

Column definitions include a validation schema that follows a familiar pattern:

```typescript
const columns = [
  { 
    field: 'name', 
    headerName: 'Name',
    fieldConfig: {
      type: 'string',
      validation: {
        required: 'Name is required',
        pattern: {
          value: /^[A-Za-z\s]+$/,
          message: 'Name must contain only letters'
        }
      }
    }
  },
  { 
    field: 'age', 
    headerName: 'Age',
    fieldConfig: {
      type: 'number',
      validation: {
        required: 'Age is required',
        min: {
          value: 18,
          message: 'Age must be at least 18'
        },
        max: {
          value: 100,
          message: 'Age must be at most 100'
        }
      }
    }
  }
]
```

## Supported Validation Rules

Our validation system supports the following rules:

- `required`: Field is required (can be a boolean or a string message)
- `min`: Minimum value for numbers
- `max`: Maximum value for numbers
- `pattern`: RegExp pattern for strings
- `validate`: Custom validation function

## Row-Level Validation

In addition to field-level validation, you can provide row-level validation to implement cross-field validation rules:

```typescript
const validateEmployeeRow = (values) => {
  const errors = {};
  
  // Example: If department is Engineering (id: 1), age must be at least 21
  if (values.departmentId === 1 && values.age < 21) {
    errors.age = 'Engineering department requires age 21+';
  }
  
  return errors;
};

<EnhancedDataGrid
  columns={columns}
  rows={data}
  validateRow={validateEmployeeRow}
/>
```

## Form State Management

Each row being edited has its own form state that tracks:

- Values
- Dirty fields
- Validation errors
- Overall validity

This state is managed internally by the GridFormContext and exposed through hooks and props as needed.

## Visual Feedback

Validation errors are displayed with:

- Red border and background for invalid fields
- Green border and background for valid fields that have been changed
- Tooltips showing error messages

## API Reference

### ValidationOptions

```typescript
interface ValidationOptions {
  required?: string | boolean;
  min?: { value: number; message: string };
  max?: { value: number; message: string };
  pattern?: { value: RegExp; message: string };
  validate?: (value: any) => string | boolean | Promise<string | boolean>;
}
```

### FieldConfig

```typescript
interface FieldConfig<T = any> {
  type: 'string' | 'number' | 'date' | 'boolean' | 'select';
  options?: Array<{value: any, label: string}>; // For select fields
  validation?: ValidationOptions;
  renderViewMode?: (value: T | null, row: any) => React.ReactNode;
  renderEditMode?: (props: any) => React.ReactNode;
  parse?: (value: any) => T | null;
  format?: (value: T | null) => string;
}
```

### EnhancedDataGridProps

```typescript
interface EnhancedDataGridProps<T = any> {
  columns: EnhancedColumnConfig[];
  rows: T[];
  onSave?: (changes: { edits: any[], additions: any[] }) => void;
  validateRow?: (values: any) => Record<string, string> | Promise<Record<string, string>>;
  // ... other props
}
```

## Migration from react-hook-form

If you were previously using react-hook-form with our DataGrid, the migration should be seamless as we've maintained the same validation schema format and API. The only change is that you'll import types from our internal types instead of react-hook-form.



====== docs/architecture-evolution.md ======
Last Modified: 3/19/2025, 14:53 | Size: 4.2 KB | Lines: 113

# Architecture Evolution: Form Management in DataGrid

## Current Relationship with react-hook-form

Our DataGrid component currently has a partial dependency on `react-hook-form`, primarily using it for:

1. **Type Definitions**: We import and use types like `RegisterOptions`, `FieldError`, `FieldValues`, and `FieldPath` from react-hook-form
2. **Validation Schema Format**: Our column definitions in `EnhancedDataGridDemo.tsx` follow react-hook-form's validation schema format
3. **No Runtime Dependency**: We don't actually use react-hook-form's hooks or form state management functionality

Instead, we've implemented our own custom form management system in `GridFormContext.tsx` that mimics some of react-hook-form's concepts but operates independently.

## Roadmap for Removing react-hook-form Dependency

### Phase 1: Create Internal Type Definitions (Week 1)

1. Create a new file `types/form.ts` with our own type definitions that mirror the react-hook-form types we're using:

```typescript
// types/form.ts

// Replace react-hook-form's RegisterOptions
export interface ValidationOptions {
  required?: string | boolean;
  min?: { value: number; message: string };
  max?: { value: number; message: string };
  pattern?: { value: RegExp; message: string };
  validate?: (value: any) => string | boolean | Promise<string | boolean>;
}

// Replace react-hook-form's FieldError
export interface FieldError {
  type: string;
  message?: string;
}

// Replace react-hook-form's FieldValues
export interface FieldValues {
  [key: string]: any;
}

// Replace react-hook-form's FieldPath
export type FieldPath<TFieldValues extends FieldValues> = string;
```

### Phase 2: Refactor Components to Use Internal Types (Week 2)

1. Update imports in all files to use our internal types instead of react-hook-form types:
   - `EnhancedDataGrid.tsx`
   - `GridFormContext.tsx`
   - `ValidationIndicator.tsx`
   - `CellRenderer.tsx`
   - Any other components using react-hook-form types

2. Ensure backward compatibility by maintaining the same structure and naming conventions where appropriate.

### Phase 3: Enhance Our Form Management System (Week 3)

1. Review and refine our custom form management implementation in `GridFormContext.tsx`:
   - Simplify where possible
   - Ensure all validation features work correctly
   - Add any missing functionality that would be valuable

2. Update documentation to reflect our custom form management approach.

### Phase 4: Remove react-hook-form Dependency (Week 4)

1. Remove react-hook-form from package.json
2. Run tests to ensure everything still works correctly
3. Update README to document our form validation approach

## Design Principles for Our Implementation

### 1. Preserve Familiar Concepts

We'll maintain these familiar concepts from react-hook-form:

- **Validation Schema Format**: Keep the structure of validation rules (required, min, max, pattern, etc.)
- **Error Handling**: Maintain the concept of field errors with type and message
- **Form State**: Keep tracking dirty fields, validation state, and form values

### 2. Simplify Where Possible

Our implementation should be simpler than react-hook-form since we have more specific requirements:

- Focus only on cell/row editing in a data grid context
- Remove features we don't need (like form submission, reset, etc.)
- Optimize for our specific UI patterns

### 3. Maintain Type Safety

- Ensure strong typing throughout our implementation
- Provide good TypeScript intellisense for column definitions and validation rules

## Benefits of This Approach

1. **Reduced Dependencies**: Smaller bundle size and fewer potential conflicts
2. **Simplified Implementation**: Code that's easier to understand and maintain
3. **Tailored Solution**: Form management specifically designed for data grid editing
4. **Familiar API**: Developers familiar with react-hook-form will find our API intuitive

## Files to Clean Up During This Process

As part of this refactoring, we should also remove unused files:

1. `components/DataGrid/context/GridEditingContext.tsx` - Unused context
2. `components/DataGrid/hooks/useGridEditing.ts` - Unused hook
3. `components/DataGridDemo.tsx` - Superseded by EnhancedDataGridDemo

And either implement or remove:

4. `components/DataGrid/components/AddRowButton.tsx` - Currently deferred feature



